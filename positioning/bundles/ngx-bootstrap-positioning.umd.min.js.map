{"version":3,"sources":["../../../../src/positioning/utils/getStyleComputedProperty.ts","../../../../src/positioning/utils/getParentNode.ts","../../../../src/positioning/utils/getScrollParent.ts","../../../../src/positioning/utils/isBrowser.ts","../../../../src/positioning/utils/isIE.ts","../../../../src/positioning/utils/getOffsetParent.ts","../../../../src/positioning/utils/getRoot.ts","../../../../src/positioning/utils/findCommonOffsetParent.ts","../../../../src/positioning/utils/isOffsetContainer.ts","../../../../src/positioning/utils/getBordersSize.ts","../../../../src/positioning/utils/getWindowSizes.ts","../../../../src/positioning/utils/getScroll.ts","../../../../src/positioning/utils/getClientRect.ts","../../../../src/positioning/utils/getBoundingClientRect.ts","../../../../src/positioning/utils/getOffsetRectRelativeToArbitraryNode.ts","../../../../src/positioning/utils/includeScroll.ts","../../../../src/positioning/utils/isFixed.ts","../../../../src/positioning/utils/getFixedPositionOffsetParent.ts","../../../../src/positioning/utils/getBoundaries.ts","../../../../src/positioning/utils/getViewportOffsetRectRelativeToArtbitraryNode.ts","../../../../src/positioning/utils/computeAutoPlacement.ts","../../../../src/positioning/utils/getOuterSizes.ts","../../../../src/positioning/utils/getReferenceOffsets.ts","../../../../src/positioning/utils/getTargetOffsets.ts","../../../../src/positioning/utils/getOppositePlacement.ts","../../../../src/positioning/utils/isModifierEnabled.ts","../../../../src/positioning/utils/setStyles.ts","../../../../src/positioning/utils/isNumeric.ts","../../../../src/positioning/modifiers/arrow.ts","../../../../src/positioning/modifiers/flip.ts","../../../../src/positioning/utils/getOppositeVariation.ts","../../../../src/positioning/modifiers/preventOverflow.ts","../../../../src/positioning/modifiers/shift.ts","../../../../src/positioning/ng-positioning.ts","../../../../src/positioning/modifiers/initData.ts","../../../../src/positioning/utils/getOffsets.ts","../../../../src/positioning/utils/updateContainerClass.ts","../../../../src/positioning/positioning.service.ts"],"names":["getStyleComputedProperty","element","property","nodeType","css","ownerDocument","defaultView","getComputedStyle","getParentNode","nodeName","parentNode","host","getScrollParent","document","body","_a","overflow","overflowX","overflowY","test","String","isBrowser","window","isIE11","MSInputMethodContext","documentMode","isIE10","navigator","userAgent","isIE","version","getOffsetParent","documentElement","sibling","noOffsetParent","offsetParent","nextElementSibling","indexOf","getRoot","node","findCommonOffsetParent","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","firstElementChild","element1root","getBordersSize","styles","axis","sideA","sideB","parseFloat","getSize","html","computedStyle","Math","max","parseInt","getWindowSizes","height","width","getScroll","side","upperSide","scrollingElement","getClientRect","offsets","Object","assign","right","left","bottom","top","getBoundingClientRect","rect","scrollTop","scrollLeft","e","result","sizes","undefined","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getOffsetRectRelativeToArbitraryNode","children","parent","fixedPosition","runIsIE","isHTML","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","subtract","modifier","includeScroll","isFixed","getFixedPositionOffsetParent","parentElement","el","getBoundaries","target","padding","boundariesElement","boundaries","excludeScroll","relativeOffset","innerWidth","innerHeight","Number","getViewportOffsetRectRelativeToArtbitraryNode","boundariesNode","computeAutoPlacement","placement","refRect","allowedPositions","rects","sortedAreas","keys","map","key","area","sort","a","b","filteredAreas","filter","computedPlacement","position","some","allowedPosition","length","variation","split","className","replace","getOuterSizes","x","marginBottom","y","marginRight","getReferenceOffsets","getTargetOffsets","hostOffsets","targetRect","targetOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","hash","matched","getOppositePlacement","isModifierEnabled","options","modifierName","modifiers","enabled","setStyles","renderer","forEach","prop","n","unit","isNaN","isFinite","setStyle","style","arrow","data","arrowElement","instance","querySelector","isVertical","len","sideCapitalized","toLowerCase","altSide","opSide","arrowElementSize","placementVariation","center","targetMarginSide","targetBorderSide","targetBorderRadius","borderRadius","targetSideArrowOffset","sideValue","min","round","flip","adaptivePosition","flipOrder","step","index","overlapsRef","floor","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariation","getOppositeVariation","preventOverflow","targetStyles","transform","check","primary","value","secondary","shift","basePlacement","shiftVariation","_d","shiftOffsets","_b","_c","Positioning","prototype","hostElement","targetElement","this","offset","positionElements","appendToBody","reduce","modifiedData","hostElPosition","match","placementAuto","matches","positionFixed","initData","positionService","getOffsets","will-change","containerClass","setAttribute","updateContainerClass","PositioningService","ngZone","rendererFactory","platformId","_this","update$$","Subject","Map","isDisabled","isPlatformBrowser","runOutsideAngular","triggerEvent$","merge","fromEvent","passive","of","animationFrameScheduler","subscribe","positionElement","_getHtmlElement","attachment","createRenderer","addPositionElement","defineProperty","disable","enable","set","calcPosition","next","deletePositionElement","elRef","delete","setOptions","ElementRef","nativeElement","i0","ɵɵinject","NgZone","RendererFactory2","PLATFORM_ID","factory","ɵfac","providedIn","Injectable","Inject"],"mappings":"qeAKgBA,EAAyBC,EAAkBC,GACzD,GAAyB,IAArBD,EAAQE,SACV,MAAO,GAGT,IACMC,EADSH,EAAQI,cAAcC,YAClBC,iBAAiBN,EAAS,MAE7C,OAAOC,EAAWE,EAAIF,GAAYE,WCRpBI,EAAcP,GAC5B,MAAyB,SAArBA,EAAQQ,SACHR,EAGFA,EAAQS,YAAcT,EAAQU,cCFvBC,EAAgBX,GAE9B,IAAKA,EACH,OAAOY,SAASC,KAGlB,OAAQb,EAAQQ,UACd,IAAK,OACL,IAAK,OACH,OAAOR,EAAQI,cAAcS,KAC/B,IAAK,YACH,OAAOb,EAAQa,KAKb,IAAAC,EAAqCf,EAAyBC,GAA5De,EAAQD,EAAAC,SAAEC,EAASF,EAAAE,UAAEC,EAASH,EAAAG,UACtC,MAAI,wBAAwBC,KAAKC,OAAOJ,GAAYI,OAAOF,GAAaE,OAAOH,IACtEhB,EAGFW,EAAgBJ,EAAcP,IC7BhC,IAAMoB,EAA8B,oBAAXC,QAA8C,oBAAbT,SCO3DU,EAASF,MAAgBC,OAAOE,uBAAyBX,SAAiBY,cAC1EC,EAASL,MAAgBC,OAAOE,uBAAwB,UAAUL,KAAKQ,UAAUC,qBAEvEC,EAAKC,GACnB,OAAgB,KAAZA,EACKP,EAEO,KAAZO,EACKJ,EAGFH,GAAUG,WCZHK,EAAgB9B,GAC9B,IAAKA,EACH,OAAOY,SAASmB,gBAWlB,IARA,IAMIC,EANEC,EAAiBL,EAAK,IAAMhB,SAASC,KAAO,KAG9CqB,EAAelC,MAAAA,OAAO,EAAPA,EAASkC,aAKrBA,IAAiBD,GACdjC,EAAQmC,oBACRH,IAAYhC,EAAQmC,oBAI1BD,GADAF,EAAUhC,EAAQmC,oBACKD,aAG3B,IAAM1B,EAAW0B,GAAgBA,EAAa1B,SAE9C,OAAKA,GAAyB,SAAbA,GAAoC,SAAbA,GAMoB,IAA1D,CAAC,KAAM,KAAM,SAAS4B,QAAQF,EAAa1B,WACY,WAAvDT,EAAyBmC,EAAc,YAEhCJ,EAAgBI,GAGlBA,EAXEF,EAAUA,EAAQ5B,cAAc2B,gBAAkBnB,SAASmB,yBC5BtDM,EAAQC,GACtB,OAAwB,OAApBA,EAAK7B,WACA4B,EAAQC,EAAK7B,YAGf6B,WCDOC,EAAuBC,EAAuBC,GAE5D,KAAKD,GAAaA,EAAStC,UAAauC,GAAaA,EAASvC,UAC5D,OAAOU,SAASmB,gBAIhB,IAAMW,EAAQF,EAASG,wBAAwBF,GAAYG,KAAKC,4BAE5DC,EAAQJ,EAAQF,EAAWC,EAC3BM,EAAML,EAAQD,EAAWD,EAGzBQ,EAAQpC,SAASqC,cACvBD,EAAME,SAASJ,EAAO,GACtBE,EAAMG,OAAOJ,EAAK,GAGlB,ICrBgC/C,EACxBQ,EDoBF4C,EAA0BJ,EAAMI,wBAGtC,GACGZ,IAAaY,GACZX,IAAaW,GACfN,EAAMO,SAASN,GAEf,MC3Be,UADTvC,GADwBR,ED6BRoD,GC5BI5C,WAMb,SAAbA,GAAuBsB,EAAgB9B,EAAQsD,qBAAuBtD,ED0B/D8B,EAAgBsB,GAHdA,EAOX,IAAMG,EAAelB,EAAQG,GAC7B,OAAIe,EAAa7C,KACR6B,EAAuBgB,EAAa7C,KAAqB+B,GAEzDF,EAAuBC,EAAWH,EAAQI,GAAyB/B,eEzC9D8C,EAAeC,EAA6BC,GAC1D,IAAMC,EAAiB,MAATD,EAAe,OAAS,MAChCE,EAAkB,SAAVD,EAAmB,QAAU,SAE3C,OACEE,WAAWJ,EAAO,SAASE,EAAK,UAChCE,WAAWJ,EAAO,SAASG,EAAK,UCRpC,SAASE,EAAQJ,EAAc7C,EAAmBkD,EAAmBC,GACnE,OAAOC,KAAKC,IACVrD,EAAK,SAAS6C,GACd7C,EAAK,SAAS6C,GACdK,EAAK,SAASL,GACdK,EAAK,SAASL,GACdK,EAAK,SAASL,GACd9B,EAAK,IACAuC,SAASJ,EAAK,SAASL,GAAS,IACnCS,SAASH,EAAc,UAAkB,WAATN,EAAoB,MAAQ,SAAW,IACvES,SAASH,EAAc,UAAkB,WAATN,EAAoB,SAAW,UAAY,IAC3E,YAIUU,EAAexD,GAC7B,IAAMC,EAAOD,EAASC,KAChBkD,EAAOnD,EAASmB,gBAChBiC,EAAgBpC,EAAK,KAAOtB,iBAAiByD,GAEnD,MAAO,CACLM,OAAQP,EAAQ,SAAUjD,EAAMkD,EAAMC,GACtCM,MAAOR,EAAQ,QAASjD,EAAMkD,EAAMC,aCrBxBO,EAAUvE,EAAsBwE,QAAA,IAAAA,IAAAA,EAAA,OAC9C,IAAMC,EAAqB,QAATD,EAAiB,YAAc,aAC3ChE,EAAWR,EAAQQ,SAEzB,GAAiB,SAAbA,GAAoC,SAAbA,EAAqB,CAC9C,IAAMuD,EAAO/D,EAAQI,cAAc2B,gBAGnC,OAFyB/B,EAAQI,cAAcsE,kBAAoBX,GAE3CU,GAG1B,OAAOzE,EAAQyE,YCTDE,EAAcC,GAC5B,OAAAC,OAAAC,OAAAD,OAAAC,OAAA,GACKF,GAAO,CACVG,MAAOH,EAAQI,KAAOJ,EAAQN,MAC9BW,OAAQL,EAAQM,IAAMN,EAAQP,kBCElBc,EAAsBnF,GACpC,IAAIoF,EAKJ,IACE,GAAIxD,EAAK,IAAK,CACZwD,EAAOpF,EAAQmF,wBACf,IAAME,EAAYd,EAAUvE,EAAS,OAC/BsF,EAAaf,EAAUvE,EAAS,QACtCoF,EAAKF,KAAOG,EACZD,EAAKJ,MAAQM,EACbF,EAAKH,QAAUI,EACfD,EAAKL,OAASO,OAEdF,EAAOpF,EAAQmF,wBAEjB,MAAOI,GACP,OAGF,IAAMC,EAAkB,CACtBR,KAAMI,EAAKJ,KACXE,IAAKE,EAAKF,IACVZ,MAAOc,EAAKL,MAAQK,EAAKJ,KACzBX,OAAQe,EAAKH,OAASG,EAAKF,KAIvBO,EAA6B,SAArBzF,EAAQQ,SAAsB4D,EAAepE,EAAQI,oBAAiBsF,EAC9EpB,EACJmB,GAASA,EAAMnB,OAAStE,EAAQ2F,aAAeH,EAAOT,MAAQS,EAAOR,KACjEX,EACJoB,GAASA,EAAMpB,QAAUrE,EAAQ4F,cAAgBJ,EAAOP,OAASO,EAAON,IAEtEW,EAAiB7F,EAAQ8F,YAAcxB,EACvCyB,EAAgB/F,EAAQgG,aAAe3B,EAI3C,GAAIwB,GAAkBE,EAAe,CACnC,IAAMtC,EAAS1D,EAAyBC,GACxC6F,GAAkBrC,EAAeC,EAAQ,KACzCsC,GAAiBvC,EAAeC,EAAQ,KAExC+B,EAAOlB,OAASuB,EAChBL,EAAOnB,QAAU0B,EAGnB,OAAOpB,EAAca,YCrDPS,EACdC,EACAC,EACAC,QAAA,IAAAA,IAAAA,GAAA,GAEA,IAAM3E,EAAS4E,EAAQ,IACjBC,EAA6B,SAApBH,EAAO3F,SAChB+F,EAAepB,EAAsBe,GACrCM,EAAarB,EAAsBgB,GACnCM,EAAe9F,EAAgBuF,GAE/BzC,EAAS1D,EAAyBoG,GAClCO,EAAiB7C,WAAWJ,EAAOiD,gBACnCC,EAAkB9C,WAAWJ,EAAOkD,iBAGtCP,GAAiBE,IACnBE,EAAWtB,IAAMjB,KAAKC,IAAIsC,EAAWtB,IAAK,GAC1CsB,EAAWxB,KAAOf,KAAKC,IAAIsC,EAAWxB,KAAM,IAG9C,IAAIJ,EAAmBD,EAAc,CACnCO,IAAKqB,EAAarB,IAAMsB,EAAWtB,IAAMwB,EACzC1B,KAAMuB,EAAavB,KAAOwB,EAAWxB,KAAO2B,EAC5CrC,MAAOiC,EAAajC,MACpBD,OAAQkC,EAAalC,SAUvB,GAPAO,EAAQgC,UAAY,EACpBhC,EAAQiC,WAAa,GAMhBpF,GAAU6E,EAAQ,CACrB,IAAMM,EAAY/C,WAAWJ,EAAOmD,WAC9BC,EAAahD,WAAWJ,EAAOoD,YAErCjC,EAAQM,KAAOwB,EAAiBE,EAChChC,EAAQK,QAAUyB,EAAiBE,EACnChC,EAAQI,MAAQ2B,EAAkBE,EAClCjC,EAAQG,OAAS4B,EAAkBE,EAGnCjC,EAAQgC,UAAYA,EACpBhC,EAAQiC,WAAaA,EAWvB,OAPEpF,IAAW2E,EACPD,EAAO9C,SAASoD,GAChBN,IAAWM,GAA0C,SAA1BA,EAAajG,YAE5CoE,WCxD0BQ,EAAepF,EAAsB8G,QAAA,IAAAA,IAAAA,GAAA,GACjE,IAAMzB,EAAYd,EAAUvE,EAAS,OAC/BsF,EAAaf,EAAUvE,EAAS,QAChC+G,EAAWD,GAAY,EAAI,EAMjC,OALA1B,EAAKF,KAAOG,EAAY0B,EACxB3B,EAAKH,QAAUI,EAAY0B,EAC3B3B,EAAKJ,MAAQM,EAAayB,EAC1B3B,EAAKL,OAASO,EAAayB,EAEpB3B,ED+CK4B,CAAcpC,EAASuB,IAG5BvB,WE3DOqC,EAAQjH,GACtB,IAAMQ,EAAWR,EAAQQ,SACzB,MAAiB,SAAbA,GAAoC,SAAbA,IAG2B,UAAlDT,EAAyBC,EAAS,aAI/BiH,EAAQ1G,EAAcP,cCRfkH,EAA6BlH,GAE3C,IAAKA,IAAYA,EAAQmH,eAAiBvF,IACzC,OAAOhB,SAASmB,gBAKjB,IAFA,IAAIqF,EAAKpH,EAAQmH,cAEVC,GAAoD,SAA9CrH,EAAyBqH,EAAI,cACxCA,EAAKA,EAAGD,cAGV,OAAOC,GAAMxG,SAASmB,yBCNRsF,EACdC,EACA5G,EACA6G,EACAC,EACApB,QAFA,IAAAmB,IAAAA,EAAA,QAEA,IAAAnB,IAAAA,GAAA,GAIA,IAAIqB,EAA+B,CAAEvC,IAAK,EAAGF,KAAM,GAC7C9C,EAAekE,EAAgBc,EAA6BI,GAAU/E,EAAuB+E,EAAQ5G,GAG3G,GAA0B,aAAtB8G,EACFC,WCtB0DzH,EAAsB0H,QAAA,IAAAA,IAAAA,GAAA,GAClF,IAAM3D,EAAO/D,EAAQI,cAAc2B,gBAC7B4F,EAAiB1B,EAAqCjG,EAAS+D,GAC/DO,EAAQL,KAAKC,IAAIH,EAAK4B,YAAatE,OAAOuG,YAAc,GACxDvD,EAASJ,KAAKC,IAAIH,EAAK6B,aAAcvE,OAAOwG,aAAe,GAE3DxC,EAAaqC,EAAkC,EAAlBnD,EAAUR,GACvCuB,EAAcoC,EAA0C,EAA1BnD,EAAUR,EAAM,QASpD,OAAOY,EAPQ,CACbO,IAAKG,EAAYyC,OAAOH,EAAezC,KAAO4C,OAAOH,EAAef,WACpE5B,KAAMM,EAAawC,OAAOH,EAAe3C,MAAQ8C,OAAOH,EAAed,YACvEvC,MAAKA,EACLD,OAAMA,IDSO0D,CAA8C7F,EAAckE,OACpE,CAEL,IAAI4B,OAAc,EACQ,iBAAtBR,EAE8B,UADhCQ,EAAiBrH,EAAgBJ,EAAcG,KAC5BF,WACjBwH,EAAiBV,EAAOlH,cAAc2B,iBAGxCiG,EAD+B,WAAtBR,EACQF,EAAOlH,cAAc2B,gBAErByF,EAGnB,IAAM5C,EAAUqB,EACd+B,EACA9F,EACAkE,GAIF,GAAgC,SAA5B4B,EAAexH,UAAwByG,EAAQ/E,GAQjDuF,EAAa7C,MARmD,CAC1D,IAAA9D,EAAoBsD,EAAekD,EAAOlH,eAAxCiE,EAAMvD,EAAAuD,OAAEC,EAAKxD,EAAAwD,MACrBmD,EAAWvC,KAAON,EAAQM,IAAMN,EAAQgC,UACxCa,EAAWxC,OAAS6C,OAAOzD,GAAUyD,OAAOlD,EAAQM,KACpDuC,EAAWzC,MAAQJ,EAAQI,KAAOJ,EAAQiC,WAC1CY,EAAW1C,MAAQ+C,OAAOxD,GAASwD,OAAOlD,EAAQI,OAatD,OALAyC,EAAWzC,MAAQuC,EACnBE,EAAWvC,KAAOqC,EAClBE,EAAW1C,OAASwC,EACpBE,EAAWxC,QAAUsC,EAEdE,WExDOQ,EACdC,EACAC,EACAb,EACA5G,EACA0H,EACAZ,EACAD,GAEA,QAJA,IAAAa,IAAAA,EAAA,CAAoB,MAAO,SAAU,QAAS,cAC9C,IAAAZ,IAAAA,EAAA,iBACA,IAAAD,IAAAA,EAAA,IAEmC,IAA/BW,EAAU9F,QAAQ,QACpB,OAAO8F,EAGT,IAAMT,EAAaJ,EAAcC,EAAQ5G,EAAM6G,EAASC,GAElDa,EAAQ,CACZnD,IAAK,CACHZ,MAAOmD,EAAWnD,MAClBD,OAAQ8D,EAAQjD,IAAMuC,EAAWvC,KAEnCH,MAAO,CACLT,MAAOmD,EAAW1C,MAAQoD,EAAQpD,MAClCV,OAAQoD,EAAWpD,QAErBY,OAAQ,CACNX,MAAOmD,EAAWnD,MAClBD,OAAQoD,EAAWxC,OAASkD,EAAQlD,QAEtCD,KAAM,CACJV,MAAO6D,EAAQnD,KAAOyC,EAAWzC,KACjCX,OAAQoD,EAAWpD,SAIjBiE,EAAczD,OAAO0D,KAAKF,GAC7BG,KAAI,SAAAC,GAAO,OAAA5D,OAAAC,OAAAD,OAAAC,OAAA,CACV2D,IAAGA,GACAJ,EAAMI,IAAI,CACbC,MA1CW5H,EA0CGuH,EAAMI,GA1CF3H,EAAAwD,MAAQxD,EAAAuD,UAAhC,IAAiBvD,KA4CZ6H,MAAK,SAACC,EAAGC,GAAM,OAAAA,EAAEH,KAAOE,EAAEF,QAEzBI,EAAgBR,EAAYS,QAC9B,SAACjI,OAAEwD,EAAKxD,EAAAwD,MAAED,EAAMvD,EAAAuD,OACd,OAAOC,GAASgD,EAAO3B,aAClBtB,GAAUiD,EAAO1B,gBAWpBoD,GAPNF,EAAgBA,EAAcC,QAAO,SAACE,GACpC,OAAOb,EACJc,MAAK,SAACC,GACL,OAAOA,IAAoBF,EAASR,WAIMW,OAAS,EACrDN,EAAc,GAAGL,IACjBH,EAAY,GAAGG,IAEbY,EAAYnB,EAAUoB,MAAM,KAAK,GAKvC,OAFAhC,EAAOiC,UAAYjC,EAAOiC,UAAUC,QAAQ,mBAAoB,cAAcR,GAEvEA,GAAqBK,EAAY,IAAIA,EAAc,aCvE5CI,EAAczJ,GAC5B,IACMyD,EADSzD,EAAQI,cAAcC,YACfC,iBAAiBN,GACjC0J,GAAK7F,WAAWJ,EAAOmD,YAAc,IAAM/C,WAAWJ,EAAOkG,eAAiB,GAC9EC,GAAK/F,WAAWJ,EAAOoD,aAAe,IAAMhD,WAAWJ,EAAOoG,cAAgB,GAEpF,MAAO,CACLvF,MAAOwD,OAAO9H,EAAQ8F,aAAe8D,EACrCvF,OAAQyD,OAAO9H,EAAQgG,cAAgB0D,YCL3BI,EACdxC,EACA5G,EACA0F,GAMA,YANA,IAAAA,IAAAA,EAAA,MAMOH,EAAqCvF,EAJjB0F,EACvBc,EAA6BI,GAC7B/E,EAAuB+E,EAAQ5G,GAEmC0F,YCVxD2D,EACdzC,EACA0C,EACAf,GAEA,IAAMf,EAAYe,EAASK,MAAM,KAAK,GAGhCW,EAAaR,EAAcnC,GAG3B4C,EAAgB,CACpB5F,MAAO2F,EAAW3F,MAClBD,OAAQ4F,EAAW5F,QAIf8F,GAAoD,IAA1C,CAAC,QAAS,QAAQ/H,QAAQ8F,GACpCkC,EAAWD,EAAU,MAAQ,OAC7BE,EAAgBF,EAAU,OAAS,MACnCG,EAAcH,EAAU,SAAW,QACnCI,EAAwBJ,EAAqB,QAAX,SAWxC,OATAD,EAAcE,GACZJ,EAAYI,GACZJ,EAAYM,GAAe,EAC3BL,EAAWK,GAAe,EAE5BJ,EAAcG,GAAiBnC,IAAcmC,EACzCL,EAAYK,GAAiBJ,EAAWM,GACxCP,WClC+B9B,GACnC,IAAMsC,EAAO,CAAExF,KAAM,QAASD,MAAO,OAAQE,OAAQ,MAAOC,IAAK,UAEjE,OAAOgD,EAAUsB,QAAQ,0BAA0B,SAAAiB,GAAW,OAAAD,EAAKC,MD+BnDC,CAAqBL,IAE9BH,WElCOS,EAAkBC,EAAkBC,GAClD,OAAOD,GACFA,EAAQE,WACRF,EAAQE,UAAUD,IAClBD,EAAQE,UAAUD,GAAcE,iBCFvBC,EAAUhL,EAAsByD,EAAmDwH,GACjGpG,OAAO0D,KAAK9E,GAAQyH,SAAQ,SAACC,GAC3B,ICNsBC,EDMlBC,EAAO,IAEkE,IAAzE,CAAC,QAAS,SAAU,MAAO,QAAS,SAAU,QAAQjJ,QAAQ+I,KCPvD,MADWC,EDSV3H,EAAO0H,MCRDG,MAAMzH,WAAWuH,KAAOG,SAAS1H,WAAWuH,ODS5DC,EAAO,MAGLJ,EACFA,EAASO,SAASxL,EAASmL,EAAM,GAAGhK,OAAOsC,EAAO0H,IAASE,GAK7DrL,EAAQyL,MAAMN,GAAQhK,OAAOsC,EAAO0H,IAASE,cEnBjCK,EAAMC,SAChBzB,EAAgByB,EAAK/G,QAAQ0C,OAE3BsE,EAAmCD,EAAKE,SAASvE,OAAOwE,cAAc,UAG5E,IAAKF,EACH,OAAOD,EAGT,IAAMI,GAA0E,IAA7D,CAAC,OAAQ,SAAS3J,QAAQuJ,EAAKzD,UAAUoB,MAAM,KAAK,IAEjE0C,EAAMD,EAAa,SAAW,QAC9BE,EAAkBF,EAAa,MAAQ,OACvCvH,EAAOyH,EAAgBC,cACvBC,EAAUJ,EAAa,OAAS,MAChCK,EAASL,EAAa,SAAW,QACjCM,EAAmB5C,EAAcmC,GAAcI,GAC/CM,EAAqBX,EAAKzD,UAAUoB,MAAM,KAAK,GAGjDqC,EAAK/G,QAAQlE,KAAK0L,GAAUC,EAAmB,EAAgB7H,KACjE,EAAgBA,IACd,EAAgBA,IAASmH,EAAK/G,QAAQlE,KAAK0L,GAAUC,IAGrDvE,OAAO,EAAOlD,QAAQlE,KAAK8D,IAASsD,OAAOuE,GAAoB,EAAgBD,KACjF,EAAgB5H,IACdsD,OAAO,EAAOlD,QAAQlE,KAAK8D,IAASsD,OAAOuE,GAAoBvE,OAAO,EAAgBsE,KAE1FlC,EAAgBvF,EAAcuF,GAI9B,IAKIqC,EALEpM,EAAMJ,EAAyB4L,EAAKE,SAASvE,QAC7CkF,EAAmB3I,WAAW1D,EAAI,SAAS8L,IAC3CQ,EAAmB5I,WAAW1D,EAAI,SAAS8L,EAAe,UAIhE,GAAKK,EAEE,CACL,IAAMI,EAAqB7I,WAAW1D,EAAIwM,cACpCC,EAAwB9E,OAAO0E,EAAmBC,EAAmBC,GAC3EH,EAAS/H,IAAS8H,EAChBxE,OAAO,EAAOlD,QAAQlE,KAAK8D,IAASoI,EACpC9E,OAAO,EAAOlD,QAAQlE,KAAK8D,IAASsD,OAAO6D,EAAK/G,QAAQlE,KAAKsL,GAAOY,QANtEL,EAASzE,OAAO,EAAOlD,QAAQlE,KAAK8D,IAASsD,OAAO6D,EAAK/G,QAAQlE,KAAKsL,GAAO,EAAIK,EAAmB,GAStG,IAAIQ,EACFN,EAAS,EAAgB/H,GAAQgI,EAAmBC,EAYtD,OATAI,EAAY5I,KAAKC,IAAID,KAAK6I,IAAI5C,EAAc8B,GAAOK,EAAkBQ,GAAY,GAEjFlB,EAAK/G,QAAQ8G,QAAK5K,EAAA,IACf0D,GAAOP,KAAK8I,MAAMF,GACnB/L,EAACqL,GAAU,MAGbR,EAAKE,SAASH,MAAQE,EAEfD,WCvDOqB,EAAKrB,GAGnB,GAFAA,EAAK/G,QAAQ0C,OAAS3C,EAAcgH,EAAK/G,QAAQ0C,SAE5CqD,EAAkBgB,EAAKf,QAAS,QAWnC,OATAe,EAAK/G,QAAQ0C,OAAMzC,OAAAC,OAAAD,OAAAC,OAAA,GACd6G,EAAK/G,QAAQ0C,QACbyC,EACD4B,EAAKE,SAASvE,OACdqE,EAAK/G,QAAQlE,KACbiL,EAAKzD,YAIFyD,EAGT,IAAMlE,EAAaJ,EACjBsE,EAAKE,SAASvE,OACdqE,EAAKE,SAASnL,KACd,EACA,YACA,GAGEwH,EAAYyD,EAAKzD,UAAUoB,MAAM,KAAK,GACtCD,EAAYsC,EAAKzD,UAAUoB,MAAM,KAAK,IAAM,GAM1C2D,EAAmBhF,EAAqB,OAJ1B0D,EAAK/G,QAAQlE,KAClBiL,EAAKE,SAASvE,OAChBqE,EAAKE,SAASnL,KAEsDiL,EAAKf,QAAQxC,kBACxF8E,EAAY,CAAChF,EAAW+E,GA6D9B,OA3DEC,EAAUhC,SAAQ,SAACiC,EAAMC,GACzB,GAAIlF,IAAciF,GAAQD,EAAU9D,SAAWgE,EAAQ,EACrD,OAAOzB,EAMT,IAAM0B,EACW,UAJjBnF,EAAYyD,EAAKzD,UAAUoB,MAAM,KAAK,KAKlCrF,KAAKqJ,MAAM3B,EAAK/G,QAAQ0C,OAAOvC,OAASd,KAAKqJ,MAAM3B,EAAK/G,QAAQlE,KAAKsE,OACxD,UAAdkD,GACCjE,KAAKqJ,MAAM3B,EAAK/G,QAAQ0C,OAAOtC,MAAQf,KAAKqJ,MAAM3B,EAAK/G,QAAQlE,KAAKqE,QACvD,QAAdmD,GACCjE,KAAKqJ,MAAM3B,EAAK/G,QAAQ0C,OAAOrC,QAAUhB,KAAKqJ,MAAM3B,EAAK/G,QAAQlE,KAAKwE,MACzD,WAAdgD,GACCjE,KAAKqJ,MAAM3B,EAAK/G,QAAQ0C,OAAOpC,KAAOjB,KAAKqJ,MAAM3B,EAAK/G,QAAQlE,KAAKuE,QAEjEsI,EAAgBtJ,KAAKqJ,MAAM3B,EAAK/G,QAAQ0C,OAAOtC,MAAQf,KAAKqJ,MAAM7F,EAAWzC,MAC7EwI,EAAiBvJ,KAAKqJ,MAAM3B,EAAK/G,QAAQ0C,OAAOvC,OAASd,KAAKqJ,MAAM7F,EAAW1C,OAC/E0I,EAAexJ,KAAKqJ,MAAM3B,EAAK/G,QAAQ0C,OAAOpC,KAAOjB,KAAKqJ,MAAM7F,EAAWvC,KAC3EwI,EAAkBzJ,KAAKqJ,MAAM3B,EAAK/G,QAAQ0C,OAAOrC,QAAUhB,KAAKqJ,MAAM7F,EAAWxC,QAEjF0I,EACW,SAAdzF,GAAwBqF,GACV,UAAdrF,GAAyBsF,GACX,QAAdtF,GAAuBuF,GACT,WAAdvF,GAA0BwF,EAGvB3B,GAAuD,IAA1C,CAAC,MAAO,UAAU3J,QAAQ8F,GACvC0F,EACF7B,GAA4B,SAAd1C,GAAwBkE,GACrCxB,GAA4B,UAAd1C,GAAyBmE,IACtCzB,GAA4B,SAAd1C,GAAwBoE,IACtC1B,GAA4B,UAAd1C,GAAyBqE,GAEzCL,GAAeM,GAAuBC,MACpCP,GAAeM,KACjBzF,EAAYgF,EAAUE,EAAQ,IAG5BQ,IACFvE,WCtF6BA,GACnC,MAAkB,UAAdA,EACK,OACgB,SAAdA,EACF,QAGFA,ED+EWwE,CAAqBxE,IAGnCsC,EAAKzD,UAAYA,GAAamB,EAAY,IAAIA,EAAc,IAE5DsC,EAAK/G,QAAQ0C,OAAMzC,OAAAC,OAAAD,OAAAC,OAAA,GACd6G,EAAK/G,QAAQ0C,QACbyC,EACD4B,EAAKE,SAASvE,OACdqE,EAAK/G,QAAQlE,KACbiL,EAAKzD,gBAMNyD,WEtGOmC,EAAgBnC,GAE9B,IAAKhB,EAAkBgB,EAAKf,QAAS,mBACnC,OAAOe,EAMT,IACMoC,EAAepC,EAAKE,SAASvE,OAAOmE,MACQ3K,EAAAiN,EAA1C7I,EAAGpE,EAAAoE,IAAEF,EAAIlE,EAAAkE,KAAmBgJ,EAASlN,EAAA,UAC7CiN,EAAa7I,IAAM,GACnB6I,EAAa/I,KAAO,GACpB+I,EAA0B,UAAI,GAE9B,IAAMtG,EAAaJ,EACjBsE,EAAKE,SAASvE,OACdqE,EAAKE,SAASnL,KACd,EACAiL,EAAKf,QAAQE,UAAUgD,gBAAgBtG,mBAAqB,gBAC5D,GAKFuG,EAAa7I,IAAMA,EACnB6I,EAAa/I,KAAOA,EACpB+I,EAA0B,UAAIC,EAE9B,IA4BIxJ,EA1BEyJ,EAAQ,CACZC,QAAO,SAAChG,SACFiG,EAAQxC,EAAK/G,QAAQ0C,OAAOY,GAMhC,OAJIyD,EAAK/G,QAAQ0C,OAAOY,GAAaT,EAAWS,KAC9CiG,EAAQlK,KAAKC,IAAIyH,EAAK/G,QAAQ0C,OAAOY,GAAYT,EAAWS,MAG9DpH,EAAA,IAAUoH,GAAYiG,EAAKrN,GAE7BsN,UAAS,SAAClG,SACFkC,EAAyB,UAAdlC,EAAwB,OAAS,MAC9CiG,EAAQxC,EAAK/G,QAAQ0C,OAAO8C,GAUhC,OARIuB,EAAK/G,QAAQ0C,OAAOY,GAAaT,EAAWS,KAC9CiG,EAAQlK,KAAK6I,IACXnB,EAAK/G,QAAQ0C,OAAO8C,GACpB3C,EAAWS,IACI,UAAdA,EAAwByD,EAAK/G,QAAQ0C,OAAOhD,MAAQqH,EAAK/G,QAAQ0C,OAAOjD,WAI7EvD,EAAA,IAAUsJ,GAAW+D,EAAKrN,IAmB9B,MA3Cc,CAAC,OAAQ,QAAS,MAAO,UA8BjCoK,SAAQ,SAAAhD,GACZ1D,GAC2B,IADpB,CAAC,OAAQ,OACbpC,QAAQ8F,GACP,UACA,YAEJyD,EAAK/G,QAAQ0C,OAAMzC,OAAAC,OAAAD,OAAAC,OAAA,GACd6G,EAAK/G,QAAQ0C,QACb2G,EAAMzJ,GAAM0D,OAKZyD,WC1EO0C,EAAM1C,aACdzD,EAAYyD,EAAKzD,UACjBoG,EAAgBpG,EAAUoB,MAAM,KAAK,GACrCiF,EAAiBrG,EAAUoB,MAAM,KAAK,GAE5C,GAAIiF,EAAgB,CACZ,IAAAC,EAAmB7C,EAAK/G,QAAtBlE,EAAI8N,EAAA9N,KAAE4G,EAAMkH,EAAAlH,OACdyE,GAA2D,IAA9C,CAAC,SAAU,OAAO3J,QAAQkM,GACvC9J,EAAOuH,EAAa,OAAS,MAC7BzB,EAAcyB,EAAa,QAAU,SAErC0C,EAAe,CACnB3L,OAAKhC,EAAA,GAAIA,EAAC0D,GAAO9D,EAAK8D,GAAK1D,GAC3BiC,KAAG2L,EAAA,GACDA,EAAClK,GAAO9D,EAAK8D,GAAQ9D,EAAK4J,GAAehD,EAAOgD,OAIpDqB,EAAK/G,QAAQ0C,OAAMzC,OAAAC,OAAAD,OAAAC,OAAA,GACdwC,KAAMqH,EAAA,IACNnK,GAAQA,IAAS+J,EAAiBE,EAAa3L,MAAM0B,GAAQiK,EAAa1L,IAAIyB,OAKrF,OAAOmH,mBCfT,SAAAiD,YACEA,EAAAC,UAAA5F,SAAA,SAAS6F,EAA0BC,GACjC,OAAOC,KAAKC,OAAOH,EAAaC,IAGlCH,EAAAC,UAAAI,OAAA,SAAOH,EAA0BC,GAC/B,OAAOjF,EAAoBiF,EAAeD,IAG5CF,EAAAC,UAAAK,iBAAA,SACEJ,EACAC,EACA9F,EACAkG,EACAvE,GAIA,MAFyB,CAACoC,EAAMqB,EAAOP,EAAiBpC,GAEhC0D,QACtB,SAACC,EAActI,GAAa,OAAAA,EAASsI,cCtBzCN,EAA4BD,EAA0B7F,EAAkB2B,GAGxE,IAAM0E,EAAiBxF,EAAoBiF,EAAeD,GAErD7F,EAASsG,MAAM,yCACdtG,EAASsG,MAAM,4EACXtG,EAAW,QAGrB,IAAMuG,IAAkBvG,EAASsG,MAAM,SAGnCrH,EAAYe,EAASsG,MAAM,iCAC3BtG,EAASK,MAAM,KAAK,IAAM,OAC1BL,EAGEwG,EAAUvH,EAAUqH,MAAM,6DAoBhC,OAnBIE,IACFvH,EAAYuH,EAAQ,IAAMA,EAAQ,GAAK,IAAIA,EAAQ,GAAO,MAIyB,IAAjF,CAAC,aAAc,aAAc,aAAc,cAAcrN,QAAQ8F,KACnEA,EAAY,QAaP,CACL0C,QAAOA,EACPiB,SAAU,CACRvE,OAAQyH,EACRrO,KAAMoO,EACNpD,MAAO,MAET9G,QAAS,CACP0C,OAlBiByC,EAAiBgF,EAAeO,EAAgBpH,GAmBjExH,KAAM4O,EACN5D,MAAO,MAETgE,eAAe,EACfxH,UArBFA,EAAYD,EACVC,EACAoH,EACAP,EACAD,EACAlE,EAAUA,EAAQxC,sBAAmB1C,GAiBrC8J,cAAaA,GD7BXG,CAASZ,EAAeD,EAAa7F,EAAU2B,UAK/CgF,EAAkB,IAAIhB,WAEZM,EACdJ,EACAC,EACA7G,EACAiH,EACAvE,EACAK,GAGA,IAAMU,EAAOiE,EAAgBV,iBAC3BJ,EACAC,EACA7G,EACAiH,EACAvE,GAGIhG,WEtDmB+G,GACzB,MAAO,CACLrH,MAAOqH,EAAK/G,QAAQ0C,OAAOhD,MAC3BD,OAAQsH,EAAK/G,QAAQ0C,OAAOjD,OAC5BW,KAAMf,KAAKqJ,MAAM3B,EAAK/G,QAAQ0C,OAAOtC,MACrCE,IAAKjB,KAAK8I,MAAMpB,EAAK/G,QAAQ0C,OAAOpC,KACpCD,OAAQhB,KAAK8I,MAAMpB,EAAK/G,QAAQ0C,OAAOrC,QACvCF,MAAOd,KAAKqJ,MAAM3B,EAAK/G,QAAQ0C,OAAOvC,QF+CxB8K,CAAWlE,GAE3BX,EAAU+D,EAAe,CACvBe,cAAe,YACf5K,IAAK,MACLF,KAAM,MACNgJ,UAAW,eAAepJ,EAAQI,KAAI,OAAOJ,EAAQM,IAAG,YACvD+F,GAECU,EAAKE,SAASH,OAChBV,EAAUW,EAAKE,SAASH,MAAOC,EAAK/G,QAAQ8G,MAAOT,YG5DlBU,EAAYV,GAC/C,IAAM3D,EAASqE,EAAKE,SAASvE,OAEzByI,EAAiBzI,EAAOiC,UAExBoC,EAAK6D,iBAKoC,KAF3CO,GADAA,GADAA,EAAiBA,EAAevG,QAAQ,mBAAoB,cAAcmC,EAAKzD,YAC/CsB,QAAQ,mBAAoB,cAAcmC,EAAKzD,YAC/CsB,QAAQ,UAAW,IAAImC,EAAKzD,YAEzC9F,QAAQ,aAAiE,IAA5C2N,EAAe3N,QAAQ,kBACrE2N,GAAkB,kBAGuB,IAAvCA,EAAe3N,QAAQ,aAAkE,IAA5C2N,EAAe3N,QAAQ,kBACtE2N,GAAkB,kBAItBA,EAAiBA,EAAevG,QAAQ,yBAA0B,GAAGmC,EAAKzD,UAAUoB,MAAM,KAAK,IAE3F2B,EACFA,EAAS+E,aAAa1I,EAAQ,QAASyI,GAKzCzI,EAAOiC,UAAYwG,EHoCnBE,CAAqBtE,EAAMV,oBIlB3B,SAAAiF,EACEC,EACAC,EACqBC,GAHvB,IAAAC,EAAAtB,KALQA,KAAAuB,SAAW,IAAIC,EAAAA,QACfxB,KAAAE,iBAAmB,IAAIuB,IAEvBzB,KAAA0B,YAAa,EAQfC,EAAAA,kBAAkBN,IACpBF,EAAOS,mBAAkB,WACvBN,EAAKO,cAAgBC,EAAAA,MACnBC,EAAAA,UAAU1P,OAAQ,SAAU,CAAE2P,SAAS,IACvCD,EAAAA,UAAU1P,OAAQ,SAAU,CAAE2P,SAAS,IAC7BC,EAAAA,GAAG,EAAGC,EAAAA,yBAChBZ,EAAKC,UAGPD,EAAKO,cAAcM,WAAU,WACvBb,EAAKI,YAITJ,EAAKpB,iBAEFhE,SAAQ,SAACkG,GACRlC,EACEmC,EAAgBD,EAAgB9J,QAChC+J,EAAgBD,EAAgBpR,SAChCoR,EAAgBE,WAChBF,EAAgBjC,aAChBmB,EAAK1F,QACLwF,EAAgBmB,eAAe,KAAM,uBAQnDrB,EAAArB,UAAA5F,SAAA,SAAS2B,GACPoE,KAAKwC,mBAAmB5G,IAG1B/F,OAAA4M,eAAIvB,EAAArB,UAAA,SAAM,KAAV,WACE,OAAOG,KAAK6B,+CAGdX,EAAArB,UAAA6C,QAAA,WACE1C,KAAK0B,YAAa,GAGpBR,EAAArB,UAAA8C,OAAA,WACE3C,KAAK0B,YAAa,GAGpBR,EAAArB,UAAA2C,mBAAA,SAAmB5G,GACjBoE,KAAKE,iBAAiB0C,IAAIP,EAAgBzG,EAAQ5K,SAAU4K,IAG9DsF,EAAArB,UAAAgD,aAAA,WACE7C,KAAKuB,SAASuB,QAGhB5B,EAAArB,UAAAkD,sBAAA,SAAsBC,GACpBhD,KAAKE,iBAAiB+C,OAAOZ,EAAgBW,KAG/C9B,EAAArB,UAAAqD,WAAA,SAAWtH,GACToE,KAAKpE,QAAUA,QAInB,SAASyG,EAAgBrR,GAEvB,MAAuB,iBAAZA,EACFY,SAASkL,cAAc9L,GAG5BA,aAAmBmS,EAAAA,WACdnS,EAAQoS,cAGVpS,mCAvFIkQ,GAAkBmC,EAAAC,SAAAD,EAAAE,QAAAF,EAAAC,SAAAD,EAAAG,kBAAAH,EAAAC,SAUnBG,EAAAA,mDAVCvC,EAAkBwC,QAAlBxC,EAAkByC,KAAAC,WADN,yEACZ1C,EAAkB,CAAA,MAD9B2C,EAAAA,iBAAW,CAACD,WAAY,uGAWpBE,EAAAA,aAAOL,EAAAA","sourcesContent":["/**\r\n * Get CSS computed property of the given element\r\n */\r\nexport function getStyleComputedProperty(element: Element): CSSStyleDeclaration;\r\nexport function getStyleComputedProperty(element: Element, property?: string): string | string[];\r\nexport function getStyleComputedProperty(element: Element, property?: string): string | string[] | CSSStyleDeclaration {\r\n  if (element.nodeType !== 1) {\r\n    return [];\r\n  }\r\n  // NOTE: 1 DOM access here\r\n  const window = element.ownerDocument.defaultView;\r\n  const css = window.getComputedStyle(element, null);\r\n\r\n  return property ? css[property] : css;\r\n}\r\n","/**\r\n * Returns the parentNode or the host of the element\r\n */\r\n// todo: valorkin fix\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport function getParentNode(element: any): any {\r\n  if (element.nodeName === 'HTML') {\r\n    return element;\r\n  }\r\n\r\n  return element.parentNode || element.host;\r\n}\r\n","/**\r\n * Returns the scrolling parent of the given element\r\n */\r\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\r\nimport { getParentNode } from './getParentNode';\r\n\r\n// todo: valorkin fix\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport function getScrollParent(element: any): any {\r\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\r\n  if (!element) {\r\n    return document.body;\r\n  }\r\n\r\n  switch (element.nodeName) {\r\n    case 'HTML':\r\n    case 'BODY':\r\n      return element.ownerDocument.body;\r\n    case '#document':\r\n      return element.body;\r\n    default:\r\n  }\r\n\r\n  // Firefox want us to check `-x` and `-y` variations as well\r\n  const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\r\n  if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\r\n    return element;\r\n  }\r\n\r\n  return getScrollParent(getParentNode(element));\r\n}\r\n","export const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\r\n","/**\r\n * Determines if the browser is Internet Explorer\r\n */\r\nimport { isBrowser } from './isBrowser';\r\n\r\n// todo: valorkin fix and drop IE support :evil:\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst isIE11 = isBrowser && !!(window.MSInputMethodContext && (document as any).documentMode);\r\nconst isIE10 = isBrowser && !!(window.MSInputMethodContext && /MSIE 10/.test(navigator.userAgent));\r\n\r\nexport function isIE(version?: number) {\r\n  if (version === 11) {\r\n    return isIE11;\r\n  }\r\n  if (version === 10) {\r\n    return isIE10;\r\n  }\r\n\r\n  return isIE11 || isIE10;\r\n}\r\n","/**\r\n * Returns the offset parent of the given element\r\n */\r\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\r\nimport { isIE } from './isIE';\r\n\r\nexport function getOffsetParent(element: HTMLElement): HTMLElement {\r\n  if (!element) {\r\n    return document.documentElement;\r\n  }\r\n\r\n  const noOffsetParent = isIE(10) ? document.body : null;\r\n\r\n  // NOTE: 1 DOM access here\r\n  let offsetParent = element?.offsetParent;\r\n\r\n  // Skip hidden elements which don't have an offsetParent\r\n  let sibling: HTMLElement | null;\r\n\r\n  while (offsetParent === noOffsetParent\r\n         && element.nextElementSibling\r\n         && sibling !== element.nextElementSibling) {\r\n\r\n      // todo: valorkin fix\r\n      sibling = element.nextElementSibling as HTMLElement;\r\n      offsetParent = sibling.offsetParent;\r\n    }\r\n\r\n  const nodeName = offsetParent && offsetParent.nodeName;\r\n\r\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\r\n    return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\r\n  }\r\n\r\n  // .offsetParent will return the closest TH, TD or TABLE in case\r\n  if (\r\n    ['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 &&\r\n    getStyleComputedProperty(offsetParent, 'position') === 'static'\r\n  ) {\r\n    return getOffsetParent(offsetParent as HTMLElement);\r\n  }\r\n\r\n  return offsetParent as HTMLElement;\r\n}\r\n","/**\r\n * Finds the root node (document, shadowDOM root) of the given element\r\n */\r\nexport function getRoot(node: Node|ShadowRoot): Node|ShadowRoot {\r\n  if (node.parentNode !== null) {\r\n    return getRoot(node.parentNode);\r\n  }\r\n\r\n  return node;\r\n}\r\n","/**\r\n * Finds the offset parent common to the two provided nodes\r\n */\r\nimport { isOffsetContainer } from './isOffsetContainer';\r\nimport { getRoot } from './getRoot';\r\nimport { getOffsetParent } from './getOffsetParent';\r\n\r\nexport function findCommonOffsetParent(element1: HTMLElement, element2: HTMLElement): HTMLElement {\r\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\r\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\r\n    return document.documentElement;\r\n  }\r\n\r\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\r\n    const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\r\n\r\n  const start = order ? element1 : element2;\r\n  const end = order ? element2 : element1;\r\n\r\n  // Get common ancestor container\r\n  const range = document.createRange();\r\n  range.setStart(start, 0);\r\n  range.setEnd(end, 0);\r\n\r\n  // todo: valorkin fix\r\n  const commonAncestorContainer = range.commonAncestorContainer as unknown as HTMLElement;\r\n\r\n  // Both nodes are inside #document\r\n  if (\r\n    (element1 !== commonAncestorContainer &&\r\n      element2 !== commonAncestorContainer) ||\r\n    start.contains(end)\r\n  ) {\r\n    if (isOffsetContainer(commonAncestorContainer)) {\r\n      return commonAncestorContainer;\r\n    }\r\n\r\n    return getOffsetParent(commonAncestorContainer);\r\n  }\r\n\r\n  // one of the nodes is inside shadowDOM, find which one\r\n  const element1root = getRoot(element1) as ShadowRoot;\r\n  if (element1root.host) {\r\n    return findCommonOffsetParent(element1root.host as HTMLElement, element2);\r\n  } else {\r\n    return findCommonOffsetParent(element1, (getRoot(element2) as ShadowRoot).host as HTMLElement);\r\n  }\r\n}\r\n","import { getOffsetParent } from './getOffsetParent';\r\n\r\n// todo: valorkin fix\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport function isOffsetContainer(element: any) {\r\n  const { nodeName } = element;\r\n  if (nodeName === 'BODY') {\r\n    return false;\r\n  }\r\n\r\n  return (\r\n    nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element\r\n  );\r\n}\r\n","/**\r\n * Helper to detect borders of a given element\r\n */\r\n\r\nexport function getBordersSize(styles: CSSStyleDeclaration, axis: string) {\r\n  const sideA = axis === 'x' ? 'Left' : 'Top';\r\n  const sideB = sideA === 'Left' ? 'Right' : 'Bottom';\r\n\r\n  return (\r\n    parseFloat(styles[`border${sideA}Width`]) +\r\n    parseFloat(styles[`border${sideB}Width`])\r\n  );\r\n}\r\n","import { isIE } from './isIE';\r\n\r\nfunction getSize(axis: string, body: HTMLElement, html: HTMLElement, computedStyle: CSSStyleDeclaration) {\r\n  return Math.max(\r\n    body[`offset${axis}`],\r\n    body[`scroll${axis}`],\r\n    html[`client${axis}`],\r\n    html[`offset${axis}`],\r\n    html[`scroll${axis}`],\r\n    isIE(10)\r\n      ? (parseInt(html[`offset${axis}`], 10) +\r\n      parseInt(computedStyle[`margin${axis === 'Height' ? 'Top' : 'Left'}`], 10) +\r\n      parseInt(computedStyle[`margin${axis === 'Height' ? 'Bottom' : 'Right'}`], 10))\r\n    : 0\r\n  );\r\n}\r\n\r\nexport function getWindowSizes(document: Document) {\r\n  const body = document.body;\r\n  const html = document.documentElement;\r\n  const computedStyle = isIE(10) && getComputedStyle(html);\r\n\r\n  return {\r\n    height: getSize('Height', body, html, computedStyle),\r\n    width: getSize('Width', body, html, computedStyle)\r\n  };\r\n}\r\n","/**\r\n * Gets the scroll value of the given element in the given side (top and left)\r\n */\r\nexport function getScroll(element: HTMLElement, side = 'top') {\r\n  const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\r\n  const nodeName = element.nodeName;\r\n\r\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\r\n    const html = element.ownerDocument.documentElement;\r\n    const scrollingElement = element.ownerDocument.scrollingElement || html;\r\n\r\n    return scrollingElement[upperSide];\r\n  }\r\n\r\n  return element[upperSide];\r\n}\r\n","/**\r\n * Given element offsets, generate an output similar to getBoundingClientRect\r\n */\r\nimport { Offsets } from '../models';\r\n\r\nexport function getClientRect(offsets: Offsets): Offsets {\r\n  return {\r\n    ...offsets,\r\n    right: offsets.left + offsets.width,\r\n    bottom: offsets.top + offsets.height\r\n  };\r\n}\r\n","/**\r\n * Get bounding client rect of given element\r\n */\r\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\r\nimport { getBordersSize } from './getBordersSize';\r\nimport { getWindowSizes } from './getWindowSizes';\r\nimport { getScroll } from './getScroll';\r\nimport { getClientRect } from './getClientRect';\r\nimport { isIE } from './isIE';\r\nimport { Offsets } from '../models';\r\n\r\nexport function getBoundingClientRect(element: HTMLElement): Offsets {\r\n  let rect: Offsets;\r\n\r\n  // IE10 10 FIX: Please, don't ask, the element isn't\r\n  // considered in DOM in some circumstances...\r\n  // This isn't reproducible in IE10 compatibility mode of IE11\r\n  try {\r\n    if (isIE(10)) {\r\n      rect = element.getBoundingClientRect();\r\n      const scrollTop = getScroll(element, 'top');\r\n      const scrollLeft = getScroll(element, 'left');\r\n      rect.top += scrollTop;\r\n      rect.left += scrollLeft;\r\n      rect.bottom += scrollTop;\r\n      rect.right += scrollLeft;\r\n    } else {\r\n      rect = element.getBoundingClientRect();\r\n    }\r\n  } catch (e) {\r\n    return undefined;\r\n  }\r\n\r\n  const result: Offsets = {\r\n    left: rect.left,\r\n    top: rect.top,\r\n    width: rect.right - rect.left,\r\n    height: rect.bottom - rect.top\r\n  };\r\n\r\n  // subtract scrollbar size from sizes\r\n  const sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : undefined;\r\n  const width =\r\n    sizes && sizes.width || element.clientWidth || result.right - result.left;\r\n  const height =\r\n    sizes && sizes.height || element.clientHeight || result.bottom - result.top;\r\n\r\n  let horizScrollbar = element.offsetWidth - width;\r\n  let vertScrollbar = element.offsetHeight - height;\r\n\r\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\r\n  // we make this check conditional for performance reasons\r\n  if (horizScrollbar || vertScrollbar) {\r\n    const styles = getStyleComputedProperty(element);\r\n    horizScrollbar -= getBordersSize(styles, 'x');\r\n    vertScrollbar -= getBordersSize(styles, 'y');\r\n\r\n    result.width -= horizScrollbar;\r\n    result.height -= vertScrollbar;\r\n  }\r\n\r\n  return getClientRect(result);\r\n}\r\n","import { getBoundingClientRect } from './getBoundingClientRect';\r\nimport { getClientRect } from './getClientRect';\r\nimport { getScrollParent } from './getScrollParent';\r\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\r\nimport { includeScroll } from './includeScroll';\r\nimport { isIE as runIsIE } from './isIE';\r\nimport { Offsets } from '../models';\r\n\r\nexport function getOffsetRectRelativeToArbitraryNode(\r\n  children: HTMLElement,\r\n  parent: HTMLElement,\r\n  fixedPosition = false\r\n): Offsets {\r\n  const isIE10 = runIsIE(10);\r\n  const isHTML = parent.nodeName === 'HTML';\r\n  const childrenRect = getBoundingClientRect(children);\r\n  const parentRect = getBoundingClientRect(parent);\r\n  const scrollParent = getScrollParent(children);\r\n\r\n  const styles = getStyleComputedProperty(parent);\r\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\r\n  const borderLeftWidth = parseFloat(styles.borderLeftWidth);\r\n\r\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\r\n  if (fixedPosition && isHTML) {\r\n    parentRect.top = Math.max(parentRect.top, 0);\r\n    parentRect.left = Math.max(parentRect.left, 0);\r\n  }\r\n\r\n  let offsets: Offsets = getClientRect({\r\n    top: childrenRect.top - parentRect.top - borderTopWidth,\r\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\r\n    width: childrenRect.width,\r\n    height: childrenRect.height\r\n  });\r\n\r\n  offsets.marginTop = 0;\r\n  offsets.marginLeft = 0;\r\n\r\n  // Subtract margins of documentElement in case it's being used as parent\r\n  // we do this only on HTML because it's the only element that behaves\r\n  // differently when margins are applied to it. The margins are included in\r\n  // the box of the documentElement, in the other cases not.\r\n  if (!isIE10 && isHTML) {\r\n    const marginTop = parseFloat(styles.marginTop);\r\n    const marginLeft = parseFloat(styles.marginLeft);\r\n\r\n    offsets.top -= borderTopWidth - marginTop;\r\n    offsets.bottom -= borderTopWidth - marginTop;\r\n    offsets.left -= borderLeftWidth - marginLeft;\r\n    offsets.right -= borderLeftWidth - marginLeft;\r\n\r\n    // Attach marginTop and marginLeft because in some circumstances we may need them\r\n    offsets.marginTop = marginTop;\r\n    offsets.marginLeft = marginLeft;\r\n  }\r\n\r\n  if (\r\n    isIE10 && !fixedPosition\r\n      ? parent.contains(scrollParent)\r\n      : parent === scrollParent && scrollParent.nodeName !== 'BODY'\r\n  ) {\r\n    offsets = includeScroll(offsets, parent);\r\n  }\r\n\r\n  return offsets;\r\n}\r\n","/**\r\n * Sum or subtract the element scroll values (left and top) from a given rect object\r\n */\r\nimport { getScroll } from './getScroll';\r\nimport { Offsets } from '../models';\r\n\r\nexport function includeScroll(rect: Offsets, element: HTMLElement, subtract = false) {\r\n  const scrollTop = getScroll(element, 'top');\r\n  const scrollLeft = getScroll(element, 'left');\r\n  const modifier = subtract ? -1 : 1;\r\n  rect.top += scrollTop * modifier;\r\n  rect.bottom += scrollTop * modifier;\r\n  rect.left += scrollLeft * modifier;\r\n  rect.right += scrollLeft * modifier;\r\n\r\n  return rect;\r\n}\r\n","/**\r\n * Check if the given element is fixed or is inside a fixed parent\r\n */\r\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\r\nimport { getParentNode } from './getParentNode';\r\n\r\nexport function isFixed(element: HTMLElement): boolean {\r\n  const nodeName = element.nodeName;\r\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\r\n    return false;\r\n  }\r\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\r\n    return true;\r\n  }\r\n\r\n  return isFixed(getParentNode(element));\r\n}\r\n","/**\r\n * Finds the first parent of an element that has a transformed property defined\r\n */\r\n\r\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\r\nimport { isIE } from './isIE';\r\n\r\nexport function getFixedPositionOffsetParent(element: HTMLElement): HTMLElement {\r\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\r\n  if (!element || !element.parentElement || isIE()) {\r\n   return document.documentElement;\r\n  }\r\n\r\n  let el = element.parentElement;\r\n\r\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\r\n    el = el.parentElement;\r\n  }\r\n\r\n  return el || document.documentElement;\r\n}\r\n","/**\r\n * Computed the boundaries limits and return them\r\n */\r\nimport { getScrollParent } from './getScrollParent';\r\nimport { getParentNode } from './getParentNode';\r\nimport { findCommonOffsetParent } from './findCommonOffsetParent';\r\nimport { getOffsetRectRelativeToArbitraryNode } from './getOffsetRectRelativeToArbitraryNode';\r\nimport { getViewportOffsetRectRelativeToArtbitraryNode } from './getViewportOffsetRectRelativeToArtbitraryNode';\r\nimport { getWindowSizes } from './getWindowSizes';\r\nimport { isFixed } from './isFixed';\r\nimport { getFixedPositionOffsetParent } from './getFixedPositionOffsetParent';\r\nimport { Offsets } from '../models';\r\n\r\nexport function getBoundaries(\r\n  target: HTMLElement,\r\n  host: HTMLElement,\r\n  padding = 0,\r\n  boundariesElement: string,\r\n  fixedPosition = false\r\n) {\r\n  // NOTE: 1 DOM access here\r\n\r\n  let boundaries: Partial<Offsets> = { top: 0, left: 0 };\r\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\r\n\r\n  // Handle viewport case\r\n  if (boundariesElement === 'viewport') {\r\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\r\n  } else {\r\n    // Handle other cases based on DOM element used as boundaries\r\n    let boundariesNode;\r\n    if (boundariesElement === 'scrollParent') {\r\n      boundariesNode = getScrollParent(getParentNode(host));\r\n      if (boundariesNode.nodeName === 'BODY') {\r\n        boundariesNode = target.ownerDocument.documentElement;\r\n      }\r\n    } else if (boundariesElement === 'window') {\r\n      boundariesNode = target.ownerDocument.documentElement;\r\n    } else {\r\n      boundariesNode = boundariesElement;\r\n    }\r\n\r\n    const offsets = getOffsetRectRelativeToArbitraryNode(\r\n      boundariesNode,\r\n      offsetParent,\r\n      fixedPosition\r\n    );\r\n\r\n    // In case of HTML, we need a different computation\r\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\r\n      const { height, width } = getWindowSizes(target.ownerDocument);\r\n      boundaries.top += offsets.top - offsets.marginTop;\r\n      boundaries.bottom = Number(height) + Number(offsets.top);\r\n      boundaries.left += offsets.left - offsets.marginLeft;\r\n      boundaries.right = Number(width) + Number(offsets.left);\r\n    } else {\r\n      // for all the other DOM elements, this one is good\r\n      boundaries = offsets;\r\n    }\r\n  }\r\n\r\n  // Add paddings\r\n  boundaries.left += padding;\r\n  boundaries.top += padding;\r\n  boundaries.right -= padding;\r\n  boundaries.bottom -= padding;\r\n\r\n  return boundaries;\r\n}\r\n","import { getClientRect } from './getClientRect';\r\nimport { getOffsetRectRelativeToArbitraryNode } from './getOffsetRectRelativeToArbitraryNode';\r\nimport { getScroll } from './getScroll';\r\nimport { Offsets } from '../models';\r\n\r\nexport function getViewportOffsetRectRelativeToArtbitraryNode(element: HTMLElement, excludeScroll = false): Offsets {\r\n  const html = element.ownerDocument.documentElement;\r\n  const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\r\n  const width = Math.max(html.clientWidth, window.innerWidth || 0);\r\n  const height = Math.max(html.clientHeight, window.innerHeight || 0);\r\n\r\n  const scrollTop = !excludeScroll ? getScroll(html) : 0;\r\n  const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\r\n\r\n  const offset = {\r\n    top: scrollTop - Number(relativeOffset.top) + Number(relativeOffset.marginTop),\r\n    left: scrollLeft - Number(relativeOffset.left) + Number(relativeOffset.marginLeft),\r\n    width,\r\n    height\r\n  };\r\n\r\n  return getClientRect(offset);\r\n}\r\n","/**\r\n * Utility used to transform the `auto` placement to the placement with more\r\n * available space.\r\n */\r\nimport { getBoundaries } from './getBoundaries';\r\nimport { Offsets } from '../models';\r\n\r\nfunction getArea({ width, height }: Record<string, number>) {\r\n  return width * height;\r\n}\r\n\r\nexport function computeAutoPlacement(\r\n  placement: string,\r\n  refRect: Offsets,\r\n  target: HTMLElement,\r\n  host: HTMLElement,\r\n  allowedPositions = ['top', 'bottom', 'right', 'left'],\r\n  boundariesElement = 'viewport',\r\n  padding = 0\r\n) {\r\n  if (placement.indexOf('auto') === -1) {\r\n    return placement;\r\n  }\r\n\r\n  const boundaries = getBoundaries(target, host, padding, boundariesElement);\r\n\r\n  const rects = {\r\n    top: {\r\n      width: boundaries.width,\r\n      height: refRect.top - boundaries.top\r\n    },\r\n    right: {\r\n      width: boundaries.right - refRect.right,\r\n      height: boundaries.height\r\n    },\r\n    bottom: {\r\n      width: boundaries.width,\r\n      height: boundaries.bottom - refRect.bottom\r\n    },\r\n    left: {\r\n      width: refRect.left - boundaries.left,\r\n      height: boundaries.height\r\n    }\r\n  };\r\n\r\n  const sortedAreas = Object.keys(rects)\r\n    .map(key => ({\r\n      key,\r\n      ...rects[key],\r\n      area: getArea(rects[key])\r\n    }))\r\n    .sort((a, b) => b.area - a.area);\r\n\r\n  let filteredAreas = sortedAreas.filter(\r\n    ({ width, height }) => {\r\n      return width >= target.clientWidth\r\n        && height >= target.clientHeight;\r\n    }\r\n  );\r\n\r\n  filteredAreas = filteredAreas.filter((position) => {\r\n    return allowedPositions\r\n      .some((allowedPosition: string) => {\r\n        return allowedPosition === position.key;\r\n      });\r\n  });\r\n\r\n  const computedPlacement: string = filteredAreas.length > 0\r\n    ? filteredAreas[0].key\r\n    : sortedAreas[0].key;\r\n\r\n  const variation = placement.split(' ')[1];\r\n\r\n  // for tooltip on auto position\r\n  target.className = target.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${computedPlacement}`);\r\n\r\n  return computedPlacement + (variation ? `-${variation}` : '');\r\n}\r\n","/**\r\n * Get the outer sizes of the given element (offset size + margins)\r\n */\r\nimport { Offsets } from '../models';\r\n\r\nexport function getOuterSizes(element: HTMLElement): Offsets {\r\n  const window = element.ownerDocument.defaultView;\r\n  const styles = window.getComputedStyle(element);\r\n  const x = (parseFloat(styles.marginTop) || 0) + (parseFloat(styles.marginBottom) || 0);\r\n  const y = (parseFloat(styles.marginLeft) || 0) + (parseFloat(styles.marginRight) || 0);\r\n\r\n  return {\r\n    width: Number(element.offsetWidth) + y,\r\n    height: Number(element.offsetHeight) + x\r\n  };\r\n}\r\n","/**\r\n * Get offsets to the reference element\r\n */\r\nimport { findCommonOffsetParent } from './findCommonOffsetParent';\r\nimport { getOffsetRectRelativeToArbitraryNode } from './getOffsetRectRelativeToArbitraryNode';\r\nimport { getFixedPositionOffsetParent } from './getFixedPositionOffsetParent';\r\nimport { Offsets } from '../models';\r\n\r\nexport function getReferenceOffsets(\r\n  target: HTMLElement,\r\n  host: HTMLElement,\r\n  fixedPosition: boolean = null\r\n): Offsets {\r\n  const commonOffsetParent = fixedPosition\r\n    ? getFixedPositionOffsetParent(target)\r\n    : findCommonOffsetParent(target, host);\r\n\r\n  return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\r\n}\r\n","/**\r\n * Get offsets to the target\r\n */\r\nimport { getOppositePlacement } from './getOppositePlacement';\r\nimport { getOuterSizes } from './getOuterSizes';\r\nimport { Offsets } from '../models';\r\n\r\nexport function getTargetOffsets(\r\n  target: HTMLElement,\r\n  hostOffsets: Offsets,\r\n  position: string\r\n): Offsets {\r\n  const placement = position.split(' ')[0];\r\n\r\n  // Get target node sizes\r\n  const targetRect = getOuterSizes(target);\r\n\r\n  // Add position, width and height to our offsets object\r\n  const targetOffsets = {\r\n    width: targetRect.width,\r\n    height: targetRect.height\r\n  };\r\n\r\n  // depending by the target placement we have to compute its offsets slightly differently\r\n  const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\r\n  const mainSide = isHoriz ? 'top' : 'left';\r\n  const secondarySide = isHoriz ? 'left' : 'top';\r\n  const measurement = isHoriz ? 'height' : 'width';\r\n  const secondaryMeasurement = !isHoriz ? 'height' : 'width';\r\n\r\n  targetOffsets[mainSide] =\r\n    hostOffsets[mainSide] +\r\n    hostOffsets[measurement] / 2 -\r\n    targetRect[measurement] / 2;\r\n\r\n  targetOffsets[secondarySide] = placement === secondarySide\r\n    ? hostOffsets[secondarySide] - targetRect[secondaryMeasurement]\r\n    : hostOffsets[getOppositePlacement(secondarySide)];\r\n\r\n  return targetOffsets;\r\n}\r\n","/**\r\n * Get the opposite placement of the given one\r\n */\r\nexport function getOppositePlacement(placement: string) {\r\n  const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\r\n\r\n  return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\r\n}\r\n","/**\r\n * Helper used to know if the given modifier is enabled.\r\n */\r\nimport { Options } from '../models';\r\n\r\nexport function isModifierEnabled(options: Options, modifierName: string): boolean {\r\n  return options\r\n    && options.modifiers\r\n    && options.modifiers[modifierName]\r\n    && options.modifiers[modifierName].enabled;\r\n}\r\n","/**\r\n * Set the style to the given popper\r\n */\r\nimport { Renderer2 } from '@angular/core';\r\n\r\nimport { isNumeric } from './isNumeric';\r\n\r\nexport function setStyles(element: HTMLElement, styles: Record<string, string|number|HTMLElement>, renderer?: Renderer2) {\r\n  Object.keys(styles).forEach((prop) => {\r\n    let unit = '';\r\n    // add unit if the value is numeric and is one of the following\r\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 &&\r\n      isNumeric(styles[prop] as string)) {\r\n      unit = 'px';\r\n    }\r\n\r\n    if (renderer) {\r\n      renderer.setStyle(element, prop, `${String(styles[prop])}${unit}`);\r\n\r\n      return;\r\n    }\r\n\r\n    element.style[prop] = String(styles[prop]) + unit;\r\n  });\r\n}\r\n","/**\r\n * Tells if a given input is a number\r\n */\r\nexport function isNumeric(n: string): boolean {\r\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(parseFloat(n));\r\n}\r\n","import { getClientRect, getOuterSizes, getStyleComputedProperty } from '../utils';\r\nimport { Data } from '../models';\r\n\r\nexport function arrow(data: Data) {\r\n  let targetOffsets = data.offsets.target;\r\n  // if arrowElement is a string, suppose it's a CSS selector\r\n  const arrowElement: HTMLElement | null = data.instance.target.querySelector('.arrow');\r\n\r\n  // if arrowElement is not found, don't run the modifier\r\n  if (!arrowElement) {\r\n    return data;\r\n  }\r\n\r\n  const isVertical = ['left', 'right'].indexOf(data.placement.split(' ')[0]) !== -1;\r\n\r\n  const len = isVertical ? 'height' : 'width';\r\n  const sideCapitalized = isVertical ? 'Top' : 'Left';\r\n  const side = sideCapitalized.toLowerCase();\r\n  const altSide = isVertical ? 'left' : 'top';\r\n  const opSide = isVertical ? 'bottom' : 'right';\r\n  const arrowElementSize = getOuterSizes(arrowElement)[len];\r\n  const placementVariation = data.placement.split(' ')[1];\r\n\r\n  // top/left side\r\n  if (data.offsets.host[opSide] - arrowElementSize < (targetOffsets)[side]) {\r\n    (targetOffsets)[side] -=\r\n      (targetOffsets)[side] - (data.offsets.host[opSide] - arrowElementSize);\r\n  }\r\n  // bottom/right side\r\n  if (Number((data).offsets.host[side]) + Number(arrowElementSize) > (targetOffsets)[opSide]) {\r\n    (targetOffsets)[side] +=\r\n      Number((data).offsets.host[side]) + Number(arrowElementSize) - Number((targetOffsets)[opSide]);\r\n  }\r\n  targetOffsets = getClientRect(targetOffsets);\r\n\r\n  // Compute the sideValue using the updated target offsets\r\n  // take target margin in account because we don't have this info available\r\n  const css = getStyleComputedProperty(data.instance.target);\r\n  const targetMarginSide = parseFloat(css[`margin${sideCapitalized}`]);\r\n  const targetBorderSide = parseFloat(css[`border${sideCapitalized}Width`]);\r\n\r\n  // compute center of the target\r\n  let center: number;\r\n  if (!placementVariation) {\r\n    center = Number((data).offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\r\n  } else {\r\n    const targetBorderRadius = parseFloat(css.borderRadius);\r\n    const targetSideArrowOffset = Number(targetMarginSide + targetBorderSide + targetBorderRadius);\r\n    center = side === placementVariation ?\r\n      Number((data).offsets.host[side]) + targetSideArrowOffset :\r\n      Number((data).offsets.host[side]) + Number(data.offsets.host[len] - targetSideArrowOffset);\r\n  }\r\n\r\n  let sideValue =\r\n    center - (targetOffsets)[side] - targetMarginSide - targetBorderSide;\r\n\r\n  // prevent arrowElement from being placed not contiguously to its target\r\n  sideValue = Math.max(Math.min(targetOffsets[len] - arrowElementSize, sideValue), 0);\r\n\r\n  data.offsets.arrow = {\r\n    [side]: Math.round(sideValue),\r\n    [altSide]: '' // make sure to unset any eventual altSide value from the DOM node\r\n  };\r\n\r\n  data.instance.arrow = arrowElement;\r\n\r\n  return data;\r\n}\r\n","import {\r\n  computeAutoPlacement,\r\n  getBoundaries,\r\n  getClientRect,\r\n  getOppositeVariation,\r\n  getTargetOffsets,\r\n  isModifierEnabled\r\n} from '../utils';\r\n\r\nimport { Data } from '../models';\r\n\r\nexport function flip(data: Data): Data {\r\n  data.offsets.target = getClientRect(data.offsets.target);\r\n\r\n  if (!isModifierEnabled(data.options, 'flip')) {\r\n\r\n    data.offsets.target = {\r\n      ...data.offsets.target,\r\n      ...getTargetOffsets(\r\n        data.instance.target,\r\n        data.offsets.host,\r\n        data.placement\r\n      )\r\n    };\r\n\r\n    return data;\r\n  }\r\n\r\n  const boundaries = getBoundaries(\r\n    data.instance.target,\r\n    data.instance.host,\r\n    0, // padding\r\n    'viewport',\r\n    false // positionFixed\r\n  );\r\n\r\n  let placement = data.placement.split(' ')[0];\r\n  let variation = data.placement.split(' ')[1] || '';\r\n\r\n  const offsetsHost = data.offsets.host;\r\n  const target = data.instance.target;\r\n  const host = data.instance.host;\r\n\r\n  const adaptivePosition = computeAutoPlacement('auto', offsetsHost, target, host, data.options.allowedPositions);\r\n  const flipOrder = [placement, adaptivePosition];\r\n\r\n    flipOrder.forEach((step, index) => {\r\n    if (placement !== step || flipOrder.length === index + 1) {\r\n      return data;\r\n    }\r\n\r\n    placement = data.placement.split(' ')[0];\r\n\r\n    // using floor because the host offsets may contain decimals we are not going to consider here\r\n    const overlapsRef =\r\n      (placement === 'left' &&\r\n        Math.floor(data.offsets.target.right) > Math.floor(data.offsets.host.left)) ||\r\n      (placement === 'right' &&\r\n        Math.floor(data.offsets.target.left) < Math.floor(data.offsets.host.right)) ||\r\n      (placement === 'top' &&\r\n        Math.floor(data.offsets.target.bottom) > Math.floor(data.offsets.host.top)) ||\r\n      (placement === 'bottom' &&\r\n        Math.floor(data.offsets.target.top) < Math.floor(data.offsets.host.bottom));\r\n\r\n    const overflowsLeft = Math.floor(data.offsets.target.left) < Math.floor(boundaries.left);\r\n    const overflowsRight = Math.floor(data.offsets.target.right) > Math.floor(boundaries.right);\r\n    const overflowsTop = Math.floor(data.offsets.target.top) < Math.floor(boundaries.top);\r\n    const overflowsBottom = Math.floor(data.offsets.target.bottom) > Math.floor(boundaries.bottom);\r\n\r\n    const overflowsBoundaries =\r\n      (placement === 'left' && overflowsLeft) ||\r\n      (placement === 'right' && overflowsRight) ||\r\n      (placement === 'top' && overflowsTop) ||\r\n      (placement === 'bottom' && overflowsBottom);\r\n\r\n    // flip the variation if required\r\n    const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\r\n    const flippedVariation =\r\n      ((isVertical && variation === 'left' && overflowsLeft) ||\r\n        (isVertical && variation === 'right' && overflowsRight) ||\r\n        (!isVertical && variation === 'left' && overflowsTop) ||\r\n        (!isVertical && variation === 'right' && overflowsBottom));\r\n\r\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\r\n      if (overlapsRef || overflowsBoundaries) {\r\n        placement = flipOrder[index + 1];\r\n      }\r\n\r\n      if (flippedVariation) {\r\n        variation = getOppositeVariation(variation);\r\n      }\r\n\r\n      data.placement = placement + (variation ? ` ${variation}` : '');\r\n\r\n      data.offsets.target = {\r\n        ...data.offsets.target,\r\n        ...getTargetOffsets(\r\n          data.instance.target,\r\n          data.offsets.host,\r\n          data.placement\r\n        )\r\n      };\r\n    }\r\n  });\r\n\r\n  return data;\r\n}\r\n","/**\r\n * Get the opposite placement variation of the given one\r\n */\r\nexport function getOppositeVariation(variation: string) {\r\n  if (variation === 'right') {\r\n    return 'left';\r\n  } else if (variation === 'left') {\r\n    return 'right';\r\n  }\r\n\r\n  return variation;\r\n}\r\n","import { getBoundaries, isModifierEnabled } from '../utils';\r\nimport { Data } from '../models';\r\n\r\nexport function preventOverflow(data: Data) {\r\n\r\n  if (!isModifierEnabled(data.options, 'preventOverflow')) {\r\n    return data;\r\n  }\r\n\r\n  // NOTE: DOM access here\r\n  // resets the target Offsets's position so that the document size can be calculated excluding\r\n  // the size of the targetOffsets element itself\r\n  const transformProp = 'transform';\r\n  const targetStyles = data.instance.target.style; // assignment to help minification\r\n  const { top, left, [transformProp]: transform } = targetStyles;\r\n  targetStyles.top = '';\r\n  targetStyles.left = '';\r\n  targetStyles[transformProp] = '';\r\n\r\n  const boundaries = getBoundaries(\r\n    data.instance.target,\r\n    data.instance.host,\r\n    0, // padding\r\n    data.options.modifiers.preventOverflow.boundariesElement || 'scrollParent',\r\n    false // positionFixed\r\n  );\r\n\r\n  // NOTE: DOM access here\r\n  // restores the original style properties after the offsets have been computed\r\n  targetStyles.top = top;\r\n  targetStyles.left = left;\r\n  targetStyles[transformProp] = transform;\r\n\r\n  const order = ['left', 'right', 'top', 'bottom'];\r\n\r\n  const check = {\r\n    primary(placement: string) {\r\n      let value = data.offsets.target[placement];\r\n      // options.escapeWithReference\r\n      if (data.offsets.target[placement] < boundaries[placement]) {\r\n        value = Math.max(data.offsets.target[placement], boundaries[placement]);\r\n      }\r\n\r\n      return { [placement]: value };\r\n    },\r\n    secondary(placement: string) {\r\n      const mainSide = placement === 'right' ? 'left' : 'top';\r\n      let value = data.offsets.target[mainSide];\r\n      // escapeWithReference\r\n      if (data.offsets.target[placement] > boundaries[placement]) {\r\n        value = Math.min(\r\n          data.offsets.target[mainSide],\r\n          boundaries[placement] -\r\n          (placement === 'right' ? data.offsets.target.width : data.offsets.target.height)\r\n        );\r\n      }\r\n\r\n      return { [mainSide]: value };\r\n    }\r\n  };\r\n\r\n  let side: string;\r\n\r\n  order.forEach(placement => {\r\n    side = ['left', 'top']\r\n      .indexOf(placement) !== -1\r\n      ? 'primary'\r\n      : 'secondary';\r\n\r\n    data.offsets.target = {\r\n      ...data.offsets.target,\r\n      ...check[side](placement)\r\n    };\r\n\r\n  });\r\n\r\n  return data;\r\n}\r\n","import { Data } from '../models';\r\n\r\nexport function shift(data: Data): Data {\r\n  const placement = data.placement;\r\n  const basePlacement = placement.split(' ')[0];\r\n  const shiftVariation = placement.split(' ')[1];\r\n\r\n  if (shiftVariation) {\r\n    const { host, target } = data.offsets;\r\n    const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\r\n    const side = isVertical ? 'left' : 'top';\r\n    const measurement = isVertical ? 'width' : 'height';\r\n\r\n    const shiftOffsets = {\r\n      start: { [side]: host[side] },\r\n      end: {\r\n        [side]: host[side] + host[measurement] - target[measurement]\r\n      }\r\n    };\r\n\r\n    data.offsets.target = {\r\n      ...target, ...{\r\n        [side]: (side === shiftVariation ? shiftOffsets.start[side] : shiftOffsets.end[side])\r\n      }\r\n    };\r\n  }\r\n\r\n  return data;\r\n}\r\n","/**\r\n * @copyright Valor Software\r\n * @copyright Federico Zivolo and contributors\r\n */\r\nimport { Renderer2 } from '@angular/core';\r\n\r\nimport { getOffsets, getReferenceOffsets, updateContainerClass, setStyles } from './utils';\r\n\r\nimport { arrow, flip, preventOverflow, shift, initData } from './modifiers';\r\nimport { Data, Offsets, Options } from './models';\r\n\r\n\r\nexport class Positioning {\r\n  position(hostElement: HTMLElement, targetElement: HTMLElement/*, round = true*/): Offsets {\r\n    return this.offset(hostElement, targetElement/*, false*/);\r\n  }\r\n\r\n  offset(hostElement: HTMLElement, targetElement: HTMLElement/*, round = true*/): Offsets {\r\n    return getReferenceOffsets(targetElement, hostElement);\r\n  }\r\n\r\n  positionElements(\r\n    hostElement: HTMLElement,\r\n    targetElement: HTMLElement,\r\n    position: string,\r\n    appendToBody?: boolean,\r\n    options?: Options\r\n  ): Data {\r\n    const chainOfModifiers = [flip, shift, preventOverflow, arrow];\r\n\r\n    return chainOfModifiers.reduce(\r\n      (modifiedData, modifier) => modifier(modifiedData),\r\n      initData(targetElement, hostElement, position, options)\r\n    );\r\n  }\r\n}\r\n\r\nconst positionService = new Positioning();\r\n\r\nexport function positionElements(\r\n  hostElement: HTMLElement,\r\n  targetElement: HTMLElement,\r\n  placement: string,\r\n  appendToBody?: boolean,\r\n  options?: Options,\r\n  renderer?: Renderer2\r\n): void {\r\n\r\n  const data = positionService.positionElements(\r\n    hostElement,\r\n    targetElement,\r\n    placement,\r\n    appendToBody,\r\n    options\r\n  );\r\n\r\n  const offsets = getOffsets(data);\r\n\r\n  setStyles(targetElement, {\r\n    'will-change': 'transform',\r\n    top: '0px',\r\n    left: '0px',\r\n    transform: `translate3d(${offsets.left}px, ${offsets.top}px, 0px)`\r\n  }, renderer);\r\n\r\n  if (data.instance.arrow) {\r\n    setStyles(data.instance.arrow, data.offsets.arrow, renderer);\r\n  }\r\n\r\n  updateContainerClass(data, renderer);\r\n}\r\n","import {\r\n  computeAutoPlacement,\r\n  getReferenceOffsets,\r\n  getTargetOffsets\r\n} from '../utils';\r\n\r\nimport { Data, Options } from '../models';\r\n\r\nexport function initData(\r\n  targetElement: HTMLElement, hostElement: HTMLElement, position: string, options: Options\r\n): Data {\r\n\r\n  const hostElPosition = getReferenceOffsets(targetElement, hostElement);\r\n\r\n  if (!position.match(/^(auto)*\\s*(left|right|top|bottom)*$/)\r\n    && !position.match(/^(left|right|top|bottom)*(?: (left|right|top|bottom))?\\s*(start|end)*$/)) {\r\n            position = 'auto';\r\n    }\r\n\r\n  const placementAuto = !!position.match(/auto/g);\r\n\r\n  // support old placements 'auto left|right|top|bottom'\r\n  let placement = position.match(/auto\\s(left|right|top|bottom)/)\r\n    ? position.split(' ')[1] || 'auto'\r\n    : position;\r\n\r\n  // Normalize placements that have identical main placement and variation (\"right right\" => \"right\").\r\n  const matches = placement.match(/^(left|right|top|bottom)* ?(?!\\1)(left|right|top|bottom)?/);\r\n  if (matches) {\r\n    placement = matches[1] + (matches[2] ? ` ${matches[2]}` : '');\r\n  }\r\n\r\n  // \"left right\", \"top bottom\" etc. placements also considered incorrect.\r\n  if (['left right', 'right left', 'top bottom', 'bottom top'].indexOf(placement) !== -1) {\r\n    placement = 'auto';\r\n  }\r\n\r\n  const targetOffset = getTargetOffsets(targetElement, hostElPosition, placement);\r\n\r\n  placement = computeAutoPlacement(\r\n    placement,\r\n    hostElPosition,\r\n    targetElement,\r\n    hostElement,\r\n    options ? options.allowedPositions : undefined\r\n  );\r\n\r\n  return {\r\n    options,\r\n    instance: {\r\n      target: targetElement,\r\n      host: hostElement,\r\n      arrow: null\r\n    },\r\n    offsets: {\r\n      target: targetOffset,\r\n      host: hostElPosition,\r\n      arrow: null\r\n    },\r\n    positionFixed: false,\r\n    placement,\r\n    placementAuto\r\n  };\r\n}\r\n","import { Data, Offsets } from '../models';\r\n\r\nexport function getOffsets(data: Data): Offsets {\r\n  return {\r\n    width: data.offsets.target.width,\r\n    height: data.offsets.target.height,\r\n    left: Math.floor(data.offsets.target.left),\r\n    top: Math.round(data.offsets.target.top),\r\n    bottom: Math.round(data.offsets.target.bottom),\r\n    right: Math.floor(data.offsets.target.right)\r\n  };\r\n}\r\n","/**\r\n * Update class for the given popper\r\n */\r\nimport { Renderer2 } from '@angular/core';\r\nimport { Data } from '../models';\r\n\r\nexport function updateContainerClass(data: Data, renderer?: Renderer2): void {\r\n  const target = data.instance.target;\r\n\r\n  let containerClass = target.className;\r\n\r\n  if (data.placementAuto) {\r\n    containerClass = containerClass.replace(/bs-popover-auto/g, `bs-popover-${data.placement}`);\r\n    containerClass = containerClass.replace(/bs-tooltip-auto/g, `bs-tooltip-${data.placement}`);\r\n    containerClass = containerClass.replace(/\\sauto/g, ` ${data.placement}`);\r\n\r\n    if (containerClass.indexOf('popover') !== -1 && containerClass.indexOf('popover-auto') === -1) {\r\n      containerClass += ' popover-auto';\r\n    }\r\n\r\n    if (containerClass.indexOf('tooltip') !== -1  && containerClass.indexOf('tooltip-auto') === -1) {\r\n      containerClass += ' tooltip-auto';\r\n    }\r\n  }\r\n\r\n  containerClass = containerClass.replace(/left|right|top|bottom/g, `${data.placement.split(' ')[0]}`);\r\n\r\n  if (renderer) {\r\n    renderer.setAttribute(target, 'class', containerClass);\r\n\r\n    return;\r\n  }\r\n\r\n  target.className = containerClass;\r\n}\r\n","import { Injectable, ElementRef, RendererFactory2, Inject, PLATFORM_ID, NgZone } from '@angular/core';\r\nimport { isPlatformBrowser } from '@angular/common';\r\n\r\nimport { positionElements } from './ng-positioning';\r\n\r\nimport { fromEvent, merge, of, animationFrameScheduler, Subject, Observable } from 'rxjs';\r\nimport { Options } from './models';\r\n\r\n\r\nexport interface PositioningOptions {\r\n  /** The DOM element, ElementRef, or a selector string of an element which will be moved */\r\n  element?: HTMLElement | ElementRef | string;\r\n\r\n  /** The DOM element, ElementRef, or a selector string of an element which the element will be attached to  */\r\n  target?: HTMLElement | ElementRef | string;\r\n\r\n  /**\r\n   * A string of the form 'vert-attachment horiz-attachment' or 'placement'\r\n   * - placement can be \"top\", \"bottom\", \"left\", \"right\"\r\n   * not yet supported:\r\n   * - vert-attachment can be any of 'top', 'middle', 'bottom'\r\n   * - horiz-attachment can be any of 'left', 'center', 'right'\r\n   */\r\n  attachment?: string;\r\n\r\n  /** A string similar to `attachment`. The one difference is that, if it's not provided,\r\n   * `targetAttachment` will assume the mirror image of `attachment`.\r\n   */\r\n  targetAttachment?: string;\r\n\r\n  /** A string of the form 'vert-offset horiz-offset'\r\n   * - vert-offset and horiz-offset can be of the form \"20px\" or \"55%\"\r\n   */\r\n  offset?: string;\r\n\r\n  /** A string similar to `offset`, but referring to the offset of the target */\r\n  targetOffset?: string;\r\n\r\n  /** If true component will be attached to body */\r\n  appendToBody?: boolean;\r\n}\r\n\r\n\r\n@Injectable({providedIn: 'root'})\r\nexport class PositioningService {\r\n  private options: Options;\r\n  private update$$ = new Subject<null>();\r\n  private positionElements = new Map();\r\n  private triggerEvent$: Observable<number|Event>;\r\n  private isDisabled = false;\r\n\r\n  constructor(\r\n    ngZone: NgZone,\r\n    rendererFactory: RendererFactory2,\r\n    @Inject(PLATFORM_ID) platformId: number\r\n  ) {\r\n\r\n    if (isPlatformBrowser(platformId)) {\r\n      ngZone.runOutsideAngular(() => {\r\n        this.triggerEvent$ = merge(\r\n          fromEvent(window, 'scroll', { passive: true }),\r\n          fromEvent(window, 'resize', { passive: true }),\r\n                    of(0, animationFrameScheduler),\r\n          this.update$$\r\n        );\r\n\r\n        this.triggerEvent$.subscribe(() => {\r\n          if (this.isDisabled) {\r\n            return;\r\n          }\r\n\r\n          this.positionElements\r\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            .forEach((positionElement: any) => {\r\n              positionElements(\r\n                _getHtmlElement(positionElement.target),\r\n                _getHtmlElement(positionElement.element),\r\n                positionElement.attachment,\r\n                positionElement.appendToBody,\r\n                this.options,\r\n                rendererFactory.createRenderer(null, null)\r\n              );\r\n            });\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  position(options: PositioningOptions): void {\r\n    this.addPositionElement(options);\r\n  }\r\n\r\n  get event$(): Observable<number|Event> {\r\n    return this.triggerEvent$;\r\n  }\r\n\r\n  disable(): void {\r\n    this.isDisabled = true;\r\n  }\r\n\r\n  enable(): void {\r\n    this.isDisabled = false;\r\n  }\r\n\r\n  addPositionElement(options: PositioningOptions): void {\r\n    this.positionElements.set(_getHtmlElement(options.element), options);\r\n  }\r\n\r\n  calcPosition(): void {\r\n    this.update$$.next();\r\n  }\r\n\r\n  deletePositionElement(elRef: ElementRef): void {\r\n    this.positionElements.delete(_getHtmlElement(elRef));\r\n  }\r\n\r\n  setOptions(options: Options) {\r\n    this.options = options;\r\n  }\r\n}\r\n\r\nfunction _getHtmlElement(element: HTMLElement | ElementRef | string): HTMLElement {\r\n  // it means that we got a selector\r\n  if (typeof element === 'string') {\r\n    return document.querySelector(element);\r\n  }\r\n\r\n  if (element instanceof ElementRef) {\r\n    return element.nativeElement;\r\n  }\r\n\r\n  return element;\r\n}\r\n"]}