{"version":3,"file":"flip.js","sourceRoot":"","sources":["../../../../../src/positioning/modifiers/flip.ts"],"names":[],"mappings":"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","sourcesContent":["import {\r\n  computeAutoPlacement,\r\n  getBoundaries,\r\n  getClientRect,\r\n  getOppositeVariation,\r\n  getTargetOffsets,\r\n  isModifierEnabled\r\n} from '../utils';\r\n\r\nimport { Data } from '../models';\r\n\r\nexport function flip(data: Data): Data {\r\n  data.offsets.target = getClientRect(data.offsets.target);\r\n\r\n  if (!isModifierEnabled(data.options, 'flip')) {\r\n\r\n    data.offsets.target = {\r\n      ...data.offsets.target,\r\n      ...getTargetOffsets(\r\n        data.instance.target,\r\n        data.offsets.host,\r\n        data.placement\r\n      )\r\n    };\r\n\r\n    return data;\r\n  }\r\n\r\n  const boundaries = getBoundaries(\r\n    data.instance.target,\r\n    data.instance.host,\r\n    0, // padding\r\n    'viewport',\r\n    false // positionFixed\r\n  );\r\n\r\n  let placement = data.placement.split(' ')[0];\r\n  let variation = data.placement.split(' ')[1] || '';\r\n\r\n  const offsetsHost = data.offsets.host;\r\n  const target = data.instance.target;\r\n  const host = data.instance.host;\r\n\r\n  const adaptivePosition = computeAutoPlacement('auto', offsetsHost, target, host, data.options.allowedPositions);\r\n  const flipOrder = [placement, adaptivePosition];\r\n\r\n    flipOrder.forEach((step, index) => {\r\n    if (placement !== step || flipOrder.length === index + 1) {\r\n      return data;\r\n    }\r\n\r\n    placement = data.placement.split(' ')[0];\r\n\r\n    // using floor because the host offsets may contain decimals we are not going to consider here\r\n    const overlapsRef =\r\n      (placement === 'left' &&\r\n        Math.floor(data.offsets.target.right) > Math.floor(data.offsets.host.left)) ||\r\n      (placement === 'right' &&\r\n        Math.floor(data.offsets.target.left) < Math.floor(data.offsets.host.right)) ||\r\n      (placement === 'top' &&\r\n        Math.floor(data.offsets.target.bottom) > Math.floor(data.offsets.host.top)) ||\r\n      (placement === 'bottom' &&\r\n        Math.floor(data.offsets.target.top) < Math.floor(data.offsets.host.bottom));\r\n\r\n    const overflowsLeft = Math.floor(data.offsets.target.left) < Math.floor(boundaries.left);\r\n    const overflowsRight = Math.floor(data.offsets.target.right) > Math.floor(boundaries.right);\r\n    const overflowsTop = Math.floor(data.offsets.target.top) < Math.floor(boundaries.top);\r\n    const overflowsBottom = Math.floor(data.offsets.target.bottom) > Math.floor(boundaries.bottom);\r\n\r\n    const overflowsBoundaries =\r\n      (placement === 'left' && overflowsLeft) ||\r\n      (placement === 'right' && overflowsRight) ||\r\n      (placement === 'top' && overflowsTop) ||\r\n      (placement === 'bottom' && overflowsBottom);\r\n\r\n    // flip the variation if required\r\n    const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\r\n    const flippedVariation =\r\n      ((isVertical && variation === 'left' && overflowsLeft) ||\r\n        (isVertical && variation === 'right' && overflowsRight) ||\r\n        (!isVertical && variation === 'left' && overflowsTop) ||\r\n        (!isVertical && variation === 'right' && overflowsBottom));\r\n\r\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\r\n      if (overlapsRef || overflowsBoundaries) {\r\n        placement = flipOrder[index + 1];\r\n      }\r\n\r\n      if (flippedVariation) {\r\n        variation = getOppositeVariation(variation);\r\n      }\r\n\r\n      data.placement = placement + (variation ? ` ${variation}` : '');\r\n\r\n      data.offsets.target = {\r\n        ...data.offsets.target,\r\n        ...getTargetOffsets(\r\n          data.instance.target,\r\n          data.offsets.host,\r\n          data.placement\r\n        )\r\n      };\r\n    }\r\n  });\r\n\r\n  return data;\r\n}\r\n"]}