{"version":3,"file":"min-max.js","sourceRoot":"","sources":["../../../../../src/chronos/moment/min-max.ts"],"names":[],"mappings":"AAAA,oEAAoE;AACpE,0DAA0D;AAC1D,EAAE;AACF,yEAAyE;AACzE,+CAA+C;AAC/C,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,MAAM,sBAAsB,CAAC;AAC5D,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,uBAAuB,CAAC;AAG1D,SAAS,MAAM,CAAC,EAA0D,EAAE,KAAwB;IAClG,IAAI,MAAc,CAAC;IACnB,MAAM,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IAC3B,IAAI,OAAO,CAAO,SAAS,CAAC,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;QAClD,MAAM,GAAG,SAAS,CAAC;KACpB;SAAM,IAAI,OAAO,CAAO,KAAK,CAAC,EAAE;QAC/B,MAAM,GAAG,KAAK,CAAC;KAChB;IAED,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;QAC7B,OAAO,IAAI,IAAI,EAAE,CAAC;KACnB;IACD,IAAI,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;IACpB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;QACtC,sDAAsD;QACtD,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE;YAC5D,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;SACjB;KACF;IAED,OAAO,GAAG,CAAC;AACb,CAAC;AAED,6BAA6B;AAC7B,MAAM,UAAU,GAAG,CAAC,GAAG,IAAY;IACjC,4CAA4C;IAE5C,OAAO,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;AAChC,CAAC;AAED,MAAM,UAAU,GAAG,CAAC,GAAG,IAAY;IACjC,4CAA4C;IAE5C,OAAO,MAAM,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;AAC/B,CAAC","sourcesContent":["// Pick a moment m from moments so that m[fn](other) is true for all\r\n// other. This relies on the function fn to be transitive.\r\n//\r\n// moments should either be an array of moment objects or an array, whose\r\n// first element is an array of moment objects.\r\nimport { isArray, isDateValid } from '../utils/type-checks';\r\nimport { isAfter, isBefore } from '../utils/date-compare';\r\nimport { UnitOfTime } from '../types';\r\n\r\nfunction pickBy(fn: (date: Date, date2: Date, unit: UnitOfTime) => boolean, dates: Date[] | Date[][]): Date {\r\n  let _dates: Date[];\r\n  const _firstArg = dates[0];\r\n  if (isArray<Date>(_firstArg) && dates.length === 1) {\r\n    _dates = _firstArg;\r\n  } else if (isArray<Date>(dates)) {\r\n    _dates = dates;\r\n  }\r\n\r\n  if (!_dates || !_dates.length) {\r\n    return new Date();\r\n  }\r\n  let res = _dates[0];\r\n  for (let i = 1; i < _dates.length; ++i) {\r\n    // if (!moments[i].isValid() || moments[i][fn](res)) {\r\n    if (!isDateValid(_dates[i]) || fn.call(null, _dates[i], res)) {\r\n      res = _dates[i];\r\n    }\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\n// TODO: Use [].sort instead?\r\nexport function min(...args: Date[]): Date {\r\n  // const args = [].slice.call(arguments, 0);\r\n\r\n  return pickBy(isBefore, args);\r\n}\r\n\r\nexport function max(...args: Date[]): Date {\r\n  // const args = [].slice.call(arguments, 0);\r\n\r\n  return pickBy(isAfter, args);\r\n}\r\n"]}