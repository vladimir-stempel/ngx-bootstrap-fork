{"version":3,"file":"from-string-and-format.js","sourceRoot":"","sources":["../../../../../src/chronos/create/from-string-and-format.ts"],"names":[],"mappings":"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","sourcesContent":["import { DateParsingConfig } from './parsing.types';\r\nimport { configFromISO, configFromRFC2822 } from './from-string';\r\nimport { expandFormat } from '../format';\r\nimport { formattingTokens, formatTokenFunctions } from '../format/format';\r\nimport { isArray, isString } from '../utils/type-checks';\r\nimport { getParseRegexForToken } from '../parse/regex';\r\nimport { addTimeToArrayFromToken } from '../parse/token';\r\nimport { HOUR } from '../units/constants';\r\nimport { configFromArray } from './from-array';\r\nimport { getParsingFlags } from './parsing-flags';\r\nimport { checkOverflow } from './check-overflow';\r\nimport { Locale } from '../locale/locale.class';\r\n\r\n// constant that refers to the ISO standard\r\n// hooks.ISO_8601 = function () {};\r\nexport const ISO_8601 = 'ISO_8601';\r\n\r\n// constant that refers to the RFC 2822 form\r\n// hooks.RFC_2822 = function () {};\r\nexport const RFC_2822 = 'RFC_2822';\r\n\r\n// date from string and format string\r\nexport function configFromStringAndFormat(config: DateParsingConfig): DateParsingConfig {\r\n  // TODO: Move this to another part of the creation flow to prevent circular deps\r\n  if (config._f === ISO_8601) {\r\n    return configFromISO(config);\r\n  }\r\n  if (config._f === RFC_2822) {\r\n    return configFromRFC2822(config);\r\n  }\r\n  config._a = [];\r\n  getParsingFlags(config).empty = true;\r\n\r\n  if (isArray(config._f) || (!config._i && config._i !== 0)) {\r\n    return config;\r\n  }\r\n\r\n  // This array is used to make a Date, either with `new Date` or `Date.UTC`\r\n\r\n  let input = config._i.toString();\r\n  let totalParsedInputLength = 0;\r\n  const inputLength = input.length;\r\n  const tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\r\n\r\n  let i;\r\n  let token;\r\n  let parsedInput;\r\n  let skipped;\r\n  for (i = 0; i < tokens.length; i++) {\r\n    token = tokens[i];\r\n    parsedInput = (input.match(getParseRegexForToken(token, config._locale)) || [])[0];\r\n    if (parsedInput) {\r\n      skipped = input.substr(0, input.indexOf(parsedInput));\r\n      if (skipped.length > 0) {\r\n        getParsingFlags(config).unusedInput.push(skipped);\r\n      }\r\n      input = input.slice(input.indexOf(parsedInput) + parsedInput.length);\r\n      totalParsedInputLength += parsedInput.length;\r\n    }\r\n    // don't parse if it's not a known token\r\n    if (formatTokenFunctions[token]) {\r\n      if (parsedInput) {\r\n        getParsingFlags(config).empty = false;\r\n      } else {\r\n        getParsingFlags(config).unusedTokens.push(token);\r\n      }\r\n\r\n      addTimeToArrayFromToken(token, parsedInput, config);\r\n    } else if (config._strict && !parsedInput) {\r\n      getParsingFlags(config).unusedTokens.push(token);\r\n    }\r\n  }\r\n\r\n  // add remaining unparsed input length to the string\r\n  getParsingFlags(config).charsLeftOver = inputLength - totalParsedInputLength;\r\n  if (input.length > 0) {\r\n    getParsingFlags(config).unusedInput.push(input);\r\n  }\r\n\r\n  // clear _12h flag if hour is <= 12\r\n  if (config._a[HOUR] <= 12 &&\r\n    getParsingFlags(config).bigHour === true &&\r\n    config._a[HOUR] > 0) {\r\n    getParsingFlags(config).bigHour = void 0;\r\n  }\r\n\r\n  getParsingFlags(config).parsedDateParts = config._a.slice(0);\r\n  getParsingFlags(config).meridiem = config._meridiem;\r\n  // handle meridiem\r\n  config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\r\n\r\n  configFromArray(config);\r\n\r\n  return checkOverflow(config);\r\n}\r\n\r\n\r\nfunction meridiemFixWrap(locale: Locale, _hour: number, meridiem: string): number {\r\n  let hour = _hour;\r\n\r\n  if (meridiem == null) {\r\n    // nothing to do\r\n    return hour;\r\n  }\r\n\r\n  if (locale.meridiemHour != null) {\r\n    return locale.meridiemHour(hour, meridiem);\r\n  }\r\n\r\n  if (locale.isPM == null) {\r\n    // this is not supposed to happen\r\n    return hour;\r\n  }\r\n  // Fallback\r\n  const isPm = locale.isPM(meridiem);\r\n  if (isPm && hour < 12) {\r\n    hour += 12;\r\n  }\r\n\r\n  if (!isPm && hour === 12) {\r\n    hour = 0;\r\n  }\r\n\r\n  return hour;\r\n}\r\n"]}