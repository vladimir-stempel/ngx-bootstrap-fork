{"version":3,"file":"typeahead-utils.js","sourceRoot":"","sources":["../../../../src/typeahead/typeahead-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { latinMap } from './latin-map';\r\n\r\nexport function latinize(str: string): string {\r\n  if (!str) {\r\n    return '';\r\n  }\r\n\r\n  return str.replace(/[^A-Za-z0-9[\\] ]/g, function (a: string): string {\r\n    return latinMap[a] || a;\r\n  });\r\n}\r\n\r\nexport function escapeRegexp(queryToEscape: string): string {\r\n  // Regex: capture the whole query string and replace it with the string\r\n  // that will be used to match the results, for example if the capture is\r\n  // 'a' the result will be \\a\r\n  return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\r\n}\r\n\r\nexport function tokenize(str: string,\r\n  wordRegexDelimiters = ' ',\r\n  phraseRegexDelimiters = '', delimitersForMultipleSearch?: string): Array<string> {\r\n\r\n  let result: string[] = [];\r\n  if (!delimitersForMultipleSearch) {\r\n    result = tokenizeWordsAndPhrases(str, wordRegexDelimiters, phraseRegexDelimiters);\r\n  } else {\r\n    const multipleSearchRegexStr = `([${delimitersForMultipleSearch}]+)`;\r\n    const delimitedTokens = str.split(new RegExp(multipleSearchRegexStr, 'g'));\r\n    const lastToken = delimitedTokens[delimitedTokens.length - 1];\r\n    if (lastToken > '') {\r\n      if (wordRegexDelimiters && phraseRegexDelimiters) {\r\n        result = tokenizeWordsAndPhrases(lastToken, wordRegexDelimiters, phraseRegexDelimiters);\r\n      } else {\r\n        result.push(lastToken);\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction tokenizeWordsAndPhrases(str: string, wordRegexDelimiters: string, phraseRegexDelimiters: string): Array<string> {\r\n  const result: string[] = [];\r\n    const regexStr = `(?:[${phraseRegexDelimiters}])([^${phraseRegexDelimiters}]+)` +\r\n  `(?:[${phraseRegexDelimiters}])|([^${wordRegexDelimiters}]+)`;\r\n  const preTokenized: string[] = str.split(new RegExp(regexStr, 'g'));\r\n  const preTokenizedLength: number = preTokenized.length;\r\n  let token: string;\r\n  const replacePhraseDelimiters = new RegExp(`[${phraseRegexDelimiters}]+`, 'g');\r\n\r\n  for (let i = 0; i < preTokenizedLength; i += 1) {\r\n    token = preTokenized[i];\r\n    if (token && token.length && token !== wordRegexDelimiters) {\r\n      result.push(token.replace(replacePhraseDelimiters, ''));\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport function getValueFromObject(object: unknown, option: string): string {\r\n  if (!option || typeof object !== 'object') {\r\n    return object.toString();\r\n  }\r\n\r\n  if (option.endsWith('()')) {\r\n    const functionName = option.slice(0, option.length - 2);\r\n\r\n    return (object[functionName] as () => string)().toString();\r\n  }\r\n\r\n  const properties: string = option\r\n    .replace(/\\[(\\w+)\\]/g, '.$1')\r\n    .replace(/^\\./, '');\r\n  const propertiesArray: string[] = properties.split('.');\r\n\r\n  for (const property of propertiesArray) {\r\n    if (property in (object as Record<string, unknown>)) {\r\n      object = object[property];\r\n    }\r\n  }\r\n  if (!object) {return ''; }\r\n\r\n  return object.toString();\r\n}\r\n"]}